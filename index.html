<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Local Pokemon Battle Sim (Gen 9)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            display: flex;
            justify-content: center;
            padding: 20px;
            margin: 0;
        }

        .container {
            width: 900px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-height: 95vh;
            overflow-y: auto;
        }

        h1,
        h2,
        h3,
        h4 {
            text-align: center;
            color: #333;
            margin: 10px 0;
        }

        /* 画面切り替え */
        .screen {
            display: none;
        }

        .active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* タブ UI */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            border-bottom: 2px solid #ddd;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            color: #666;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            background: #f9f9f9;
        }

        .tab-btn.active-tab {
            color: #ff5252;
            border-bottom: 3px solid #ff5252;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active-content {
            display: block;
        }

        /* 入力フォーム */
        .wrapper-setup {
            display: flex;
            gap: 20px;
        }

        .player-setup-col {
            flex: 1;
            background: #fafafa;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .input-group {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background: white;
        }

        .stat-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
            align-items: center;
        }

        .stat-row label {
            width: 40px;
            font-size: 12px;
            font-weight: bold;
        }

        .stat-row input,
        .stat-row select {
            font-size: 12px;
            padding: 3px;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        /* ボタン */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: #ff5252;
            color: white;
            border: none;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #ff1744;
        }

        .btn-blue {
            background: #2196F3;
        }

        .btn-blue:hover {
            background: #1976D2;
        }

        .btn-move-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .btn-move {
            background: #2196F3;
            padding: 20px;
            font-size: 14px;
        }

        .btn-move:hover {
            background: #1976D2;
        }

        .btn-switch {
            background: #FF9800;
            margin-top: 10px;
        }

        .btn-switch:hover {
            background: #F57C00;
        }

        /* バトル画面 */
        .battle-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: #eee;
            border-radius: 8px;
        }

        .hp-bar-container {
            width: 200px;
            background: #e0e0e0;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #ccc;
            margin: 5px 0;
        }

        .hp-bar {
            height: 100%;
            background: #4CAF50;
            width: 100%;
            transition: width 0.5s ease-out, background-color 0.3s;
        }

        .hp-low {
            background: #ff9800 !important;
        }

        .hp-crit {
            background: #f44336 !important;
        }

        .log-box {
            background: #263238;
            color: #eceff1;
            padding: 15px;
            height: 200px;
            overflow-y: scroll;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            border-radius: 8px;
            border: 1px solid #455a64;
            margin-bottom: 10px;
        }

        .curtain {
            text-align: center;
            padding: 50px 0;
        }

        .switch-card {
            border: 2px solid #eee;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .switch-card:hover {
            border-color: #2196F3;
        }

        .switch-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #ddd;
        }

        .file-upload-box {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            border-radius: 8px;
            background: #fafafa;
        }
    </style>
</head>

<body>

    <datalist id="pokemon-list"></datalist>

    <div class="container">
        <!-- Start Screen -->
        <div id="screen-start" class="screen active">
            <h1>ポケモン対戦シミュレーター (Gen 9)</h1>
            <p style="text-align:center">3vs3 ローカル対戦 / CSV読み込み対応</p>

            <!-- 追加: CSVアップロード UI とステータス -->
            <div class="file-upload-box" id="upload-area">
                <p>ポケモンデータCSV (ヘッダー付き) を読み込むと種族値を自動入力します</p>
                <input type="file" id="csv-input" accept=".csv" onchange="app.handleCsvUpload(this)">
            </div>
            <p id="csv-status" style="text-align:center; color:#666; font-size:14px; margin-bottom:20px;">
                データ未ロード (手動入力またはCSVアップロード)
            </p>

            <button class="btn" onclick="app.startSetup(0)">Player 1 セットアップ開始</button>
        </div>

        <!-- Setup Screen -->
        <div id="screen-setup" class="screen">
            <h2 id="setup-title">Player X パーティ編成</h2>
            <div id="setup-container"></div> <!-- Dynamic -->
            <button class="btn" id="btn-setup-next" onclick="app.finishSetupStep()">次へ</button>
        </div>

        <!-- Curtain Screen (Setup Intermission & Battle Turns) -->
        <div id="screen-curtain" class="screen">
            <div class="curtain">
                <h2 id="curtain-msg">Player X の番です</h2>
                <p id="curtain-sub">相手に見えないようにPCを操作してください。</p>
                <button class="btn" id="btn-curtain-action" onclick="app.curtainAction()">操作を開始する</button>
            </div>
        </div>

        <!-- Input Screen -->
        <div id="screen-input" class="screen">
            <h2 id="input-player-header">Player X Action</h2>
            <div class="battle-info">
                <div>
                    <strong>現在: <span id="input-active-name"></span></strong>
                    <div class="hp-bar-container">
                        <div id="input-hp-bar" class="hp-bar"></div>
                    </div>
                    <span id="input-hp-text"></span>
                </div>
            </div>

            <h3>行動選択</h3>
            <div class="btn-move-container" id="move-buttons"></div>
            <button class="btn btn-switch" onclick="app.showSwitchScreen(false)">ポケモンを交代する</button>
        </div>

        <!-- Switch Screen -->
        <div id="screen-switch" class="screen">
            <h2>交代するポケモンを選択</h2>
            <p id="switch-msg">選択してください</p>
            <div id="switch-container" class="switch-list"></div>
            <button class="btn btn-blue" id="btn-cancel-switch" onclick="app.cancelSwitch()">戻る</button>
        </div>

        <!-- Result Screen -->
        <div id="screen-result" class="screen">
            <h2>ターン結果</h2>
            <div class="battle-info">
                <!-- P1 Status -->
                <div style="text-align: left;">
                    <strong id="res-p1-name">P1</strong> (Lv.<span id="res-p1-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p1" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p1">100/100</span>
                </div>
                <!-- P2 Status -->
                <div style="text-align: right;">
                    <strong id="res-p2-name">P2</strong> (Lv.<span id="res-p2-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p2" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p2">100/100</span>
                </div>
            </div>

            <div class="log-box" id="battle-log"></div>
            <button class="btn" onclick="app.nextTurn()">次へ</button>
        </div>
    </div>

    <script>
        // ==========================================
        //  CSV設定エリア (ここを変更してください)
        // ==========================================
        const CSV_DATA_EMBEDDED = ``;
        
        // Raw URL のパスは /<owner>/<repo>/<branch>/<path> の形式にする（refs/heads は不要）
        const CSV_DATA_URL = "https://raw.githubusercontent.com/K-626/pokemon/main/%E3%83%9B%E3%82%9A%E3%82%B1%E3%83%A2%E3%83%B3%E3%83%AA%E3%82%B9%E3%83%88.csv";
        
        // 自動読み込みを有効にするには "url" または "embed" に設定します
        // "url" -> CSV_DATA_URL から fetch
        // "embed" -> CSV_DATA_EMBEDDED に埋め込んだテキストを読み込む
        // "manual" -> ファイル入力のみ（今の挙動）
        const USE_CSV_SOURCE = "url";
        // ==========================================

        // --- Constants & Config ---
        const TYPE_JP_TO_EN = {
            "ノーマル": "normal", "ほのお": "fire", "みず": "water", "くさ": "grass", "でんき": "electric",
            "こおり": "ice", "かくとう": "fighting", "どく": "poison", "じめん": "ground", "ひこう": "flying",
            "エスパー": "psychic", "むし": "bug", "いわ": "rock", "ゴースト": "ghost", "ドラゴン": "dragon",
            "あく": "dark", "はがね": "steel", "フェアリー": "fairy", "": "none"
        };

        const TYPE_CHART = {
            normal: { rock: 0.5, ghost: 0, steel: 0.5 },
            fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
            water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
            electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
            grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
            ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
            fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 },
            poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
            ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
            flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
            psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
            bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
            rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
            ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
            dragon: { dragon: 2, steel: 0.5, fairy: 0 },
            dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
            steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 },
            fairy: { fire: 0.5, fighting: 2, poison: 0.5, dragon: 2, dark: 2, steel: 0.5 },
            none: {}
        };

        const NATURE_TABLE = {
            "1.0": { name: "補正なし", up: null, down: null },
            "adamant": { name: "いじっぱり", up: "atk", down: "spa" },
            "modest": { name: "ひかえめ", up: "spa", down: "atk" },
            "bold": { name: "ずぶとい", up: "def", down: "atk" },
            "timid": { name: "おくびょう", up: "spe", down: "atk" },
            "jolly": { name: "ようき", up: "spe", down: "spa" },
            "impish": { name: "わんぱく", up: "def", down: "spa" },
            "calm": { name: "おだやか", up: "spd", down: "atk" },
            "careful": { name: "しんちょう", up: "spd", down: "spa" },
        };

        const TEAM_SIZE = 3;
        const MOVES_COUNT = 4;

        // --- CSV Data Store ---
        let pokemonDB = {};

        // --- App State ---
        const app = {
            players: [],
            setupPlayerIndex: 0,
            turn: 0,
            currentPlayerIndex: 0,
            gameActive: false,

            // init: safer with element existence checks
            init: function () {
                // Pre-load Logic
                if (USE_CSV_SOURCE === "embed" && CSV_DATA_EMBEDDED.trim() !== "") {
                    this.parseCsv(CSV_DATA_EMBEDDED);
                    const uploadAreaEl = document.getElementById('upload-area');
                    if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "埋め込みデータをロードしました";
                } else if (USE_CSV_SOURCE === "url" && CSV_DATA_URL.trim() !== "") {
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "URLからデータを読み込んでいます...";
                    fetch(CSV_DATA_URL)
                        .then(res => {
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            return res.text();
                        })
                        .then(text => {
                            this.parseCsv(text);
                            const uploadAreaEl = document.getElementById('upload-area');
                            if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                            if (csvStatusEl) csvStatusEl.innerText = "WEBデータをロードしました";
                        })
                        .catch(err => {
                            console.error(err);
                            const csvStatusEl2 = document.getElementById('csv-status');
                            if (csvStatusEl2) csvStatusEl2.innerText = "読み込みエラー (手動アップロードを使用してください)";
                        });
                }
            },

            // --- CSV Logic ---
            handleCsvUpload: function (input) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => { this.parseCsv(e.target.result); };
                reader.readAsText(file);
            },

            parseCsv: function (text) {
                // BOM除去
                if (text && text.charCodeAt && text.charCodeAt(0) === 0xFEFF) {
                    console.log('BOM detected and removed');
                    text = text.slice(1);
                }
            
                if (!text || typeof text !== 'string') {
                    console.warn('parseCsv: invalid text');
                    return;
                }

                // 改行で分割して空行除去
                const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== "");
                console.log('lines:', lines.length);

                if (lines.length < 2) {
                    console.warn('CSV: 行数不足');
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "CSVの行数が不足しています";
                    return;
                }

                // ヘッダー行を取得して表示
                const rawHeaders = lines[0].split(',').map(h => h.trim());
                console.log('raw headers:', rawHeaders);

                // ヘッダー正規化ヘルパー（全角括弧→半角、空白削除、小文字化）
                const normalize = (s) => (s || '').replace(/（/g, '(').replace(/）/g, ')').replace(/\s/g, '').toLowerCase();
                const normHeaders = rawHeaders.map(h => normalize(h));
                console.log('normalized headers:', normHeaders);

                // 緩いマッチでヘッダーのインデックスを探す
                const findHeader = (candidates) => {
                    for (let i = 0; i < normHeaders.length; i++) {
                        for (let c of candidates) {
                            if (normHeaders[i].indexOf(normalize(c)) !== -1) return i;
                        }
                    }
                    return -1;
                };

                const idxName = findHeader(['名前(日本語)', '名前（日本語）', '名前']);
                const idxHP = findHeader(['HP']);
                const idxAtk = findHeader(['攻撃', '攻']);
                const idxDef = findHeader(['防御', '防']);
                const idxSpA = findHeader(['特攻', '特']);
                const idxSpD = findHeader(['特防', '特防御']);
                const idxSpe = findHeader(['素早さ', '素早']);
                const idxT1 = findHeader(['タイプ1', 'タイプ１', 'タイプ']);
                const idxT2 = findHeader(['タイプ2', 'タイプ２']);

                console.log({ idxName, idxHP, idxAtk, idxDef, idxSpA, idxSpD, idxSpe, idxT1, idxT2 });

                if (idxName === -1 || idxHP === -1) {
                    const available = rawHeaders.join(', ');
                    alert("CSVヘッダーエラー: 必須列(名前/HP)が見つかりませんでした。\n検出ヘッダー: " + available);
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "ヘッダーエラー: 名前/HP 列が見つかりません";
                    return;
                }

                // 簡易CSVパーサ（"で囲まれたフィールド内のカンマに対応）
                const splitCsvRow = (row) => {
                    const res = [];
                    let cur = '';
                    let inQuotes = false;
                    for (let i = 0; i < row.length; i++) {
                        const ch = row[i];
                        if (ch === '"') {
                            if (inQuotes && row[i + 1] === '"') {
                                cur += '"'; i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (ch === ',' && !inQuotes) {
                            res.push(cur);
                            cur = '';
                        } else {
                            cur += ch;
                        }
                    }
                    res.push(cur);
                    return res;
                };

                let count = 0;
                pokemonDB = {};
                const listEl = document.getElementById('pokemon-list');
                if (listEl) listEl.innerHTML = '';

                for (let i = 1; i < lines.length; i++) {
                    const row = splitCsvRow(lines[i]).map(c => c.trim());
                    // 名前とHPが存在するかを確認（柔軟に扱う）
                    const name = (typeof row[idxName] !== 'undefined') ? row[idxName] : '';
                    const hpVal = (typeof row[idxHP] !== 'undefined') ? row[idxHP] : '';

                    if (!name || !hpVal) {
                        // スキップ前にログ
                        console.debug(`skip row ${i + 1}: name or HP missing`, { name, hpVal, row });
                        continue;
                    }

                    // タイプ列が存在しなければ空文字にする
                    const t1raw = (idxT1 !== -1) ? (row[idxT1] || '') : '';
                    const t2raw = (idxT2 !== -1) ? (row[idxT2] || '') : '';

                    pokemonDB[name] = {
                        hp: parseInt(hpVal) || 0,
                        atk: parseInt(row[idxAtk]) || 0,
                        def: parseInt(row[idxDef]) || 0,
                        spa: parseInt(row[idxSpA]) || 0,
                        spd: parseInt(row[idxSpD]) || 0,
                        spe: parseInt(row[idxSpe]) || 0,
                        t1: TYPE_JP_TO_EN[(t1raw || '').trim()] || "normal",
                        t2: TYPE_JP_TO_EN[(t2raw || '').trim()] || "none"
                    };

                    if (listEl) {
                        const op = document.createElement('option');
                        op.value = name;
                        listEl.appendChild(op);
                    }
                    count++;
                }

                console.log('pokemonDB entries:', count);
                const csvStatusEl = document.getElementById('csv-status');
                if (csvStatusEl) csvStatusEl.innerText = `データ準備完了: ${count} 匹`;
            },

            autoFillStats: function (name, prefix) {
                const data = pokemonDB[name];
                if (data) {
                    const getEl = (id) => document.getElementById(id);
                    if (getEl(`${prefix}_base_h`)) getEl(`${prefix}_base_h`).value = data.hp;
                    if (getEl(`${prefix}_base_a`)) getEl(`${prefix}_base_a`).value = data.atk;
                    if (getEl(`${prefix}_base_b`)) getEl(`${prefix}_base_b`).value = data.def;
                    if (getEl(`${prefix}_base_c`)) getEl(`${prefix}_base_c`).value = data.spa;
                    if (getEl(`${prefix}_base_d`)) getEl(`${prefix}_base_d`).value = data.spd;
                    if (getEl(`${prefix}_base_s`)) getEl(`${prefix}_base_s`).value = data.spe;

                    if (getEl(`${prefix}_type1`)) getEl(`${prefix}_type1`).value = data.t1;
                    if (getEl(`${prefix}_type2`)) getEl(`${prefix}_type2`).value = data.t2;
                }
            },

            // --- Setup Logic ---
            startSetup: function (pIdx) {
                this.setupPlayerIndex = pIdx;
                this.showScreen('screen-setup');
                const setupTitleEl = document.getElementById('setup-title');
                if (setupTitleEl) setupTitleEl.innerText = `Player ${pIdx + 1} パーティ編成`;
                const btn = document.getElementById('btn-setup-next');
                if (btn) btn.innerText = (pIdx === 0) ? "次へ (Player 2へ交代)" : "バトル開始！";
                this.renderSetup(pIdx);
            },

            renderSetup: function (pIdx) {
                const container = document.getElementById('setup-container');
                if (!container) return;
                let html = '<div class="wrapper-setup">';
                html += `<div class="player-setup-col">`;

                html += `<div class="pokemon-tabs-nav">`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    html += `<button class="pokemon-tab ${i === 0 ? 'active' : ''}" onclick="app.switchSetupTab(${i})">Poke ${i + 1}</button>`;
                }
                html += `</div>`;

                for (let i = 0; i < TEAM_SIZE; i++) {
                    let display = i === 0 ? 'block' : 'none';
                    const prefix = `p${pIdx}_m${i}`;

                    html += `<div id="tab-${prefix}" class="tab-content" style="display:${display}">
                        <div class="input-group">
                            <label>ポケモン名 (自動入力対)</label>
                            <input type="text" id="${prefix}_name" list="pokemon-list" placeholder="例: フシギバナ" 
                                onchange="app.autoFillStats(this.value, '${prefix}')" value="">
                            
                            <div class="stat-row" style="margin-top:10px;">
                                <label>Type</label>
                                <select id="${prefix}_type1">${this.renderTypeOptions('normal')}</select>
                                <select id="${prefix}_type2">${this.renderTypeOptions('none', true)}</select>
                            </div>

                            <div class="stat-row">
                                <label>Lv</label><input type="number" id="${prefix}_lv" value="50" style="width:50px">
                                <label>性格</label>
                                <select id="${prefix}_nature">
                                    <option value="1.0">--</option>
                                    <option value="adamant">いじっぱり(A↑ C↓)</option>
                                    <option value="jolly">ようき(S↑ C↓)</option>
                                    <option value="modest">ひかえめ(C↑ A↓)</option>
                                    <option value="timid">おくびょう(S↑ A↓)</option>
                                    <option value="bold">ずぶとい(B↑ A↓)</option>
                                    <option value="impish">わんぱく(B↑ C↓)</option>
                                    <option value="calm">おだやか(D↑ A↓)</option>
                                    <option value="careful">しんちょう(D↑ C↓)</option>
                                </select>
                            </div>
                            <div class="stat-row">
                                <strong>種 / 個 / 努</strong>
                            </div>
                            ${this.renderStatInput(prefix, 'h', 'HP')}
                            ${this.renderStatInput(prefix, 'a', '攻撃')}
                            ${this.renderStatInput(prefix, 'b', '防御')}
                            ${this.renderStatInput(prefix, 'c', '特攻')}
                            ${this.renderStatInput(prefix, 'd', '特防')}
                            ${this.renderStatInput(prefix, 's', '素早')}
                            
                            <hr>
                            <h4>技構成</h4>
                            ${this.renderMovesInput(prefix)}
                        </div>
                    </div>`;
                }
                html += `</div></div>`;
                container.innerHTML = html;
            },

            finishSetupStep: function () {
                this.savePlayerData(this.setupPlayerIndex);

                if (this.setupPlayerIndex === 0) {
                    this.showScreen('screen-curtain');
                    const curtainMsgEl = document.getElementById('curtain-msg');
                    if (curtainMsgEl) curtainMsgEl.innerText = "Player 1 セットアップ完了";
                    const curtainSubEl = document.getElementById('curtain-sub');
                    if (curtainSubEl) curtainSubEl.innerText = "Player 2 に交代してください。準備ができたらボタンを押してください。";
                    const btnCurtain = document.getElementById('btn-curtain-action');
                    if (btnCurtain) btnCurtain.onclick = () => {
                        this.startSetup(1);
                    };
                    if (btnCurtain) btnCurtain.innerText = "Player 2 セットアップへ";
                } else {
                    this.initializeBattle();
                }
            },

            savePlayerData: function (pIdx) {
                let team = [];
                for (let m = 0; m < TEAM_SIZE; m++) {
                    const prefix = `p${pIdx}_m${m}`;
                    let stats = this.calcStats(prefix);
                    let moves = [];
                    for (let j = 0; j < 4; j++) {
                        const moveNameEl = document.getElementById(`${prefix}_move${j}_name`);
                        const moveTypeEl = document.getElementById(`${prefix}_move${j}_type`);
                        const moveCatEl = document.getElementById(`${prefix}_move${j}_cat`);
                        const movePwrEl = document.getElementById(`${prefix}_move${j}_pwr`);
                        moves.push({
                            name: moveNameEl ? moveNameEl.value || '-' : '-',
                            type: moveTypeEl ? moveTypeEl.value : 'normal',
                            category: moveCatEl ? moveCatEl.value : 'physical',
                            power: movePwrEl ? parseInt(movePwrEl.value) || 0 : 0
                        });
                    }
                    const nameEl = document.getElementById(`${prefix}_name`);
                    const lvEl = document.getElementById(`${prefix}_lv`);
                    const t1El = document.getElementById(`${prefix}_type1`);
                    const t2El = document.getElementById(`${prefix}_type2`);
                    team.push({
                        name: nameEl ? (nameEl.value || `Poke${m + 1}`) : `Poke${m + 1}`,
                        lv: lvEl ? parseInt(lvEl.value) || 50 : 50,
                        stats: stats,
                        currentHp: stats.hp,
                        moves: moves,
                        types: [
                            t1El ? t1El.value : 'normal',
                            t2El ? t2El.value : 'none'
                        ]
                    });
                }
                if (this.players.length <= pIdx) this.players[pIdx] = {};
                this.players[pIdx] = {
                    name: pIdx === 0 ? "Player 1" : "Player 2",
                    team: team,
                    activeIdx: 0,
                    action: null
                };
            },

            renderStatInput: function (prefix, statKey, label) {
                return `<div class="stat-row">
                    <label>${label}</label>
                    <input type="number" id="${prefix}_base_${statKey}" placeholder="種" value="100">
                    <input type="number" id="${prefix}_iv_${statKey}" placeholder="個" value="31">
                    <input type="number" id="${prefix}_ev_${statKey}" placeholder="努" value="${statKey === 'a' || statKey === 's' ? 252 : 0}">
                </div>`;
            },

            renderTypeOptions: function (selected, includeNone = false) {
                let opts = '';
                if (includeNone) opts += `<option value="none" ${selected === 'none' ? 'selected' : ''}>なし</option>`;
                Object.keys(TYPE_CHART).forEach(k => {
                    if (k !== 'none') {
                        opts += `<option value="${k}" ${k === selected ? 'selected' : ''}>${k}</option>`;
                    }
                });
                return opts;
            },

            renderMovesInput: function (prefix) {
                let html = '<div class="move-grid">';
                for (let j = 0; j < MOVES_COUNT; j++) {
                    html += `<div class="input-group" style="margin-bottom:0; padding:5px;">
                        <input type="text" id="${prefix}_move${j}_name" placeholder="技名">
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <select id="${prefix}_move${j}_type" style="width:60px;">
                                ${this.renderTypeOptions('normal')}
                            </select>
                            <select id="${prefix}_move${j}_cat" style="width:50px;">
                                <option value="physical">物</option>
                                <option value="special">特</option>
                                <option value="status">変</option>
                            </select>
                            <input type="number" id="${prefix}_move${j}_pwr" value="0" placeholder="威" style="width:40px;">
                        </div>
                    </div>`;
                }
                html += '</div>';
                return html;
            },

            switchSetupTab: function (tabIdx) {
                const prefixBase = `p${this.setupPlayerIndex}_m`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    const el = document.getElementById(`tab-${prefixBase}${i}`);
                    if (el) el.style.display = 'none';
                }
                const showEl = document.getElementById(`tab-${prefixBase}${tabIdx}`);
                if (showEl) showEl.style.display = 'block';
                const bts = document.querySelectorAll('.pokemon-tab');
                bts.forEach(b => b.classList.remove('active'));
                if (bts[tabIdx]) bts[tabIdx].classList.add('active');
            },

            // --- Battle Flow ---

            initializeBattle: function () {
                if (!this.players[0] || !this.players[1]) {
                    alert("エラー: プレイヤーデータが不足しています");
                    return;
                }
                this.turn = 0;
                this.updateHpDisplay();
                this.startTurnCycle();
            },

            startTurnCycle: function () {
                this.currentPlayerIndex = 0;
                this.gameActive = true;
                this.checkForcedSwitchStart();
            },

            curtainAction: function () {
                if (this.gameActive) {
                    this.startTurnInput();
                }
            },

            checkForcedSwitchStart: function () {
                const p = this.players[this.currentPlayerIndex];
                if (p.team[p.activeIdx].currentHp === 0) {
                    this.showSwitchScreen(true);
                } else {
                    this.showCurtain();
                }
            },

            showCurtain: function () {
                this.showScreen('screen-curtain');
                const pName = this.players[this.currentPlayerIndex].name;
                const curtainMsgEl = document.getElementById('curtain-msg');
                if (curtainMsgEl) curtainMsgEl.innerText = `${pName} の番です`;
                const curtainSubEl = document.getElementById('curtain-sub');
                if (curtainSubEl) curtainSubEl.innerText = "相手に見えないようにPCを操作してください。";
                const btnCurtain = document.getElementById('btn-curtain-action');
                if (btnCurtain) btnCurtain.onclick = () => app.curtainAction();
                if (btnCurtain) btnCurtain.innerText = "操作を開始する";
            },

            startTurnInput: function () {
                this.showScreen('screen-input');
                const p = this.players[this.currentPlayerIndex];
                const activeMon = p.team[p.activeIdx];

                const headerEl = document.getElementById('input-player-header');
                if (headerEl) headerEl.innerText = `${p.name}: ${activeMon.name} の行動`;
                const nameEl = document.getElementById('input-active-name');
                if (nameEl) nameEl.innerText = activeMon.name;
                const hpTextEl = document.getElementById('input-hp-text');
                if (hpTextEl) hpTextEl.innerText = `${activeMon.currentHp}/${activeMon.stats.hp}`;

                const pct = (activeMon.currentHp / activeMon.stats.hp) * 100;
                const bar = document.getElementById('input-hp-bar');
                if (bar) {
                    bar.style.width = pct + '%';
                    this.setHpColor(bar, pct);
                }

                const container = document.getElementById('move-buttons');
                if (container) {
                    container.innerHTML = '';
                    activeMon.moves.forEach((m, idx) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-move';
                        btn.innerHTML = `<strong>${m.name}</strong><br>${m.type} / ${m.category === 'status' ? '-' : m.power}`;
                        btn.onclick = () => this.registerMove(idx);
                        container.appendChild(btn);
                    });
                }
            },

            registerMove: function (moveIdx, switchIdx = null) {
                if (moveIdx === -1 && switchIdx !== null) {
                    this.players[this.currentPlayerIndex].action = { type: 'switch', switchIdx: switchIdx };
                } else {
                    this.players[this.currentPlayerIndex].action = { type: 'move', moveIdx: moveIdx };
                }

                if (this.currentPlayerIndex === 0) {
                    this.currentPlayerIndex = 1;
                    this.checkForcedSwitchStart();
                } else {
                    this.resolveTurn();
                }
            },

            resolveTurn: function () {
                this.showScreen('screen-result');
                const p1 = this.players[0];
                const p2 = this.players[1];
                let log = `--- ターン ${++this.turn} ---\n`;

                let p1Act = p1.action;
                let p2Act = p2.action;
                let events = [];

                if (p1Act.type === 'switch') events.push({ type: 'switch', playerId: 0, val: p1Act.switchIdx });
                if (p2Act.type === 'switch') events.push({ type: 'switch', playerId: 1, val: p2Act.switchIdx });

                if (p1Act.type === 'move' && p2Act.type === 'move') {
                    let m1 = p1.team[p1.activeIdx];
                    let m2 = p2.team[p2.activeIdx];
                    let first = (m1.stats.spe >= m2.stats.spe) ? 0 : 1;
                    events.push({ type: 'move', playerId: first });
                    events.push({ type: 'move', playerId: 1 - first });
                } else if (p1Act.type === 'move') {
                    events.push({ type: 'move', playerId: 0 });
                } else if (p2Act.type === 'move') {
                    events.push({ type: 'move', playerId: 1 });
                }

                for (let e of events) {
                    const actorP = this.players[e.playerId];
                    const targetP = this.players[1 - e.playerId];
                    if (actorP.team[actorP.activeIdx].currentHp === 0 && e.type === 'move') continue;

                    if (e.type === 'switch') {
                        const oldName = actorP.team[actorP.activeIdx].name;
                        actorP.activeIdx = e.val;
                        const newName = actorP.team[actorP.activeIdx].name;
                        log += `${actorP.name} は ${oldName} を戻して ${newName} を繰り出した！\n`;
                        this.updateHpDisplay();
                    } else {
                        const attacker = actorP.team[actorP.activeIdx];
                        const defender = targetP.team[targetP.activeIdx];
                        const move = attacker.moves[actorP.action.moveIdx];
                        log += `${attacker.name} の ${move.name}！\n`;

                        if (move.category === 'status') {
                            log += `(変化技は未実装です)\n`;
                        } else {
                            const result = this.calcDamage(attacker, defender, move);
                            const dmg = result.damage;
                            defender.currentHp = Math.max(0, defender.currentHp - dmg);
                            log += `-> ${defender.name} に ${dmg} のダメージ！ (${defender.currentHp}/${defender.stats.hp})`;
                            if (result.superEffective > 1) log += " [効果抜群]";
                            if (result.superEffective < 1 && result.superEffective > 0) log += " [今ひとつ]";
                            if (result.superEffective === 0) log += " [無効]";
                            log += "\n";
                            if (defender.currentHp === 0) log += `-> ${defender.name} は倒れた！\n`;
                        }
                    }
                }
                const battleLogEl = document.getElementById('battle-log');
                if (battleLogEl) battleLogEl.innerText = log;
                this.updateHpDisplay();
            },

            calcDamage: function (attacker, defender, move) {
                const lv = attacker.lv;
                const power = move.power;
                if (power <= 0) return { damage: 0, superEffective: 1 };

                let a = (move.category === 'physical') ? attacker.stats.atk : attacker.stats.spa;
                let d = (move.category === 'physical') ? defender.stats.def : defender.stats.spd;

                let baseDmg = Math.floor(Math.floor(Math.floor(2 * lv / 5 + 2) * power * a / d) / 50) + 2;
                let multi = 1.0;
                let typeEff = 1.0;
                defender.types.forEach(defT => {
                    if (defT !== 'none' && TYPE_CHART[move.type] && TYPE_CHART[move.type][defT] !== undefined) {
                        typeEff *= TYPE_CHART[move.type][defT];
                    }
                });
                multi *= typeEff;
                if (attacker.types.includes(move.type)) multi *= 1.5;
                const rnd = (Math.floor(Math.random() * 16) + 85) / 100;

                return { damage: Math.floor(baseDmg * multi * rnd), superEffective: typeEff };
            },

            calcStats: function (prefix) {
                const getVal = (id) => {
                    const el = document.getElementById(id);
                    return el ? (parseInt(el.value) || 0) : 0;
                };
                const lv = getVal(`${prefix}_lv`);
                const natureKeyEl = document.getElementById(`${prefix}_nature`);
                const natureKey = natureKeyEl ? natureKeyEl.value : "1.0";
                const natureData = NATURE_TABLE[natureKey] || NATURE_TABLE["1.0"];

                const calc = (stat, isHp) => {
                    const base = getVal(`${prefix}_base_${stat}`);
                    const iv = getVal(`${prefix}_iv_${stat}`);
                    const ev = getVal(`${prefix}_ev_${stat}`);
                    let core = Math.floor((2 * base + iv + Math.floor(ev / 4)) * lv / 100);
                    if (isHp) return core + lv + 10;
                    else {
                        let res = core + 5;
                        if (natureData.up === stat) res = Math.floor(res * 1.1);
                        if (natureData.down === stat) res = Math.floor(res * 0.9);
                        return res;
                    }
                };
                return {
                    hp: calc('h', true), atk: calc('a', false), def: calc('b', false),
                    spa: calc('c', false), spd: calc('d', false), spe: calc('s', false)
                };
            },

            updateHpDisplay: function () {
                [0, 1].forEach(i => {
                    const p = this.players[i];
                    if (!p) return;
                    const active = p.team[p.activeIdx];
                    const nameEl = document.getElementById(`res-p${i + 1}-name`);
                    if (nameEl) nameEl.innerText = active.name;
                    const lvEl = document.getElementById(`res-p${i + 1}-lv`);
                    if (lvEl) lvEl.innerText = active.lv;
                    const pct = (active.currentHp / active.stats.hp) * 100;
                    const bar = document.getElementById(`res-hp-bar-p${i + 1}`);
                    const txt = document.getElementById(`res-hp-text-p${i + 1}`);
                    if (bar) bar.style.width = pct + '%';
                    if (txt) txt.innerText = `${active.currentHp}/${active.stats.hp}`;
                    if (bar) this.setHpColor(bar, pct);
                });
            },

            setHpColor: function (el, pct) {
                if (!el) return;
                el.classList.remove('hp-low', 'hp-crit');
                if (pct < 20) el.classList.add('hp-crit');
                else if (pct < 50) el.classList.add('hp-low');
            },

            showSwitchScreen: function (isForced) {
                this.showScreen('screen-switch');
                const p = this.players[this.currentPlayerIndex];
                const switchMsgEl = document.getElementById('switch-msg');
                if (switchMsgEl) switchMsgEl.innerText = isForced ? "強制交代: 選んでください" : "交代するポケモンを選択";
                const container = document.getElementById('switch-container');
                if (!container) return;
                container.innerHTML = '';
                p.team.forEach((mon, idx) => {
                    if (idx === p.activeIdx) return;
                    const card = document.createElement('div');
                    card.className = 'switch-card';
                    if (mon.currentHp === 0) card.classList.add('disabled');
                    const nameSpan = document.createElement('span');
                    nameSpan.innerText = `${idx + 1}: ${mon.name} (${mon.currentHp}/${mon.stats.hp})`;
                    card.appendChild(nameSpan);
                    card.onclick = () => {
                        if (mon.currentHp === 0 && !isForced) return;
                        this.registerMove(-1, idx);
                        this.showScreen('screen-input');
                    };
                    container.appendChild(card);
                });
            },

            cancelSwitch: function () {
                this.showScreen('screen-input');
            },

            showScreen: function (id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const el = document.getElementById(id);
                if (el) el.classList.add('active');
            },

            nextTurn: function () {
                this.showScreen('screen-curtain');
                const pNameEl = document.getElementById('curtain-msg');
                if (pNameEl) pNameEl.innerText = "ターン終了 - 次へ";
                // Reset actions
                this.players.forEach(p => p.action = null);
                this.currentPlayerIndex = 0;
            }
        };

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                app.init();
            } catch (e) {
                console.error('app.init error:', e);
            }
        });
    </script>
</body>

</html>
