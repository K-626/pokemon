<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Local Pokemon Battle Sim (Gen 9)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            display: flex;
            justify-content: center;
            padding: 20px;
            margin: 0;
        }

        .container {
            width: 900px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-height: 95vh;
            overflow-y: auto;
        }

        h1,
        h2,
        h3,
        h4 {
            text-align: center;
            color: #333;
            margin: 10px 0;
        }

        /* 画面切り替え */
        .screen {
            display: none;
        }

        .active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* タブ UI */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            border-bottom: 2px solid #dddddd;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            color: #666;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            background: #f9f9f9;
        }

        .tab-btn.active-tab {
            color: #ff5252;
            border-bottom: 3px solid #ff5252;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active-content {
            display: block;
        }

        /* 入力フォーム */
        .wrapper-setup {
            display: flex;
            gap: 20px;
        }

        .player-setup-col {
            flex: 1;
            background: #fafafa;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .input-group {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background: white;
        }

        .stat-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
            align-items: center;
        }

        .stat-row label {
            width: 40px;
            font-size: 12px;
            font-weight: bold;
        }

        .stat-row input,
        .stat-row select {
            font-size: 12px;
            padding: 3px;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        /* ボタン */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: #ff5252;
            color: white;
            border: none;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #ff1744;
        }

        .btn-blue {
            background: #2196F3;
        }

        .btn-blue:hover {
            background: #1976D2;
        }

        .btn-move-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .btn-move {
            background: #2196F3;
            padding: 20px;
            font-size: 14px;
        }

        .btn-move:hover {
            background: #1976D2;
        }

        .btn-switch {
            background: #FF9800;
            margin-top: 10px;
        }

        .btn-switch:hover {
            background: #F57C00;
        }

        /* バトル画面 */
        .battle-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: #eee;
            border-radius: 8px;
        }

        .hp-bar-container {
            width: 200px;
            background: #e0e0e0;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #ccc;
            margin: 5px 0;
        }

        .hp-bar {
            height: 100%;
            background: #4CAF50;
            width: 100%;
            transition: width 0.5s ease-out, background-color 0.3s;
        }

        .hp-low {
            background: #ff9800 !important;
        }

        .hp-crit {
            background: #f44336 !important;
        }

        .log-box {
            background: #263238;
            color: #eceff1;
            padding: 15px;
            height: 200px;
            overflow-y: scroll;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            border-radius: 8px;
            border: 1px solid #455a64;
            margin-bottom: 10px;
        }

        .curtain {
            text-align: center;
            padding: 50px 0;
        }

        .switch-card {
            border: 2px solid #eee;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .switch-card:hover {
            border-color: #2196F3;
        }

        .switch-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #ddd;
        }

        .file-upload-box {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            border-radius: 8px;
            background: #fafafa;
        }

        /* Game Over Options */
        .gameover-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .switch-move-list {
            margin-top: 5px;
            font-size: 12px;
            color: #555;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }

        .switch-move-item {
            background: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>

<body>

    <datalist id="pokemon-list"></datalist>

    <div class="container">
        <!-- Start Screen -->
        <div id="screen-start" class="screen active">
            <h1 style="margin-bottom: 5px;">ポケモン対戦シミュレーター (Gen 9)</h1>
            <p style="text-align:center; margin-top: 5px;">3vs3 ローカル対戦 / CSV読み込み対応</p>

            <!-- Game Mode Selection -->
            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; text-align: center;">
                <label style="margin-right: 20px; font-weight: bold; cursor: pointer;">
                    <input type="radio" name="gameMode" value="pvp" checked onchange="app.setGameMode('pvp')"> プレイヤー vs
                    プレイヤー
                </label>
                <label style="font-weight: bold; cursor: pointer;">
                    <input type="radio" name="gameMode" value="cpu" onchange="app.setGameMode('cpu')"> プレイヤー vs CPU
                </label>
            </div>

            <!-- 追加: CSVアップロード UI とステータス -->
            <div class="file-upload-box" id="upload-area">
                <div style="display:flex; justify-content:center; gap:20px;">
                    <div>
                        <p>1. ポケモンデータCSV (名前/HP/種族値...)</p>
                        <input type="file" id="csv-input-poke" accept=".csv"
                            onchange="app.handleCsvUpload(this, 'pokemon')">
                        <p id="csv-status-poke" style="font-size:12px; color:#666;">未ロード</p>
                    </div>
                    <div>
                        <p>2. 技データCSV (名前/タイプ/効果...)</p>
                        <input type="file" id="csv-input-move" accept=".csv"
                            onchange="app.handleCsvUpload(this, 'move')">
                        <p id="csv-status-move" style="font-size:12px; color:#666;">未ロード</p>
                    </div>
                </div>
            </div>
            <p style="text-align:center; color:#666; font-size:14px; margin-bottom:20px;">
                * データ未ロードの場合は手動入力になります<br>
                <button class="btn btn-blue" style="margin-top:10px; width:auto; padding:5px 15px; font-size:12px;"
                    onclick="app.fetchDataFromUrl()">GitHubから最新データを読み込む</button>
            </p>

            <button class="btn" onclick="app.startSetup(0)">Player 1 セットアップ開始</button>
        </div>

        <!-- Setup Screen -->
        <div id="screen-setup" class="screen">
            <h2 id="setup-title">Player X パーティ編成</h2>
            <div id="setup-container"></div> <!-- Dynamic -->
            <button class="btn" id="btn-setup-next" onclick="app.finishSetupStep()">次へ</button>
        </div>

        <!-- Curtain Screen (Setup Intermission & Battle Turns) -->
        <div id="screen-curtain" class="screen">
            <div class="curtain">
                <h2 id="curtain-msg">Player X の番です</h2>
                <p id="curtain-sub">相手に見えないようにPCを操作してください。</p>
                <button class="btn" id="btn-curtain-action" onclick="app.curtainAction()">操作を開始する</button>
            </div>
        </div>

        <!-- Input Screen -->
        <div id="screen-input" class="screen">
            <h2 id="input-player-header">Player X Action</h2>
            <div class="battle-info">
                <div>
                    <strong>現在: <span id="input-active-name"></span></strong>
                    <div class="hp-bar-container">
                        <div id="input-hp-bar" class="hp-bar"></div>
                    </div>
                    <span id="input-hp-text"></span>
                    <div id="input-active-ranks" style="font-size: 14px; margin-top: 5px; color: #444;"></div>
                </div>
                <!-- Weather Indicator -->
                <div id="weather-indicator"
                    style="background:#fff; padding:5px 10px; border-radius:5px; border:1px solid #ccc; font-weight:bold; height:fit-content;">
                    天候: なし</div>
            </div>

            <h3>行動選択</h3>
            <div class="btn-move-container" id="move-buttons"></div>
            <button class="btn btn-switch" onclick="app.showSwitchScreen(false)">ポケモンを交代する</button>
        </div>

        <!-- Switch Screen -->
        <div id="screen-switch" class="screen">
            <h2>交代するポケモンを選択</h2>
            <p id="switch-msg">選択してください</p>
            <div id="switch-container" class="switch-list"></div>
            <button class="btn btn-blue" id="btn-cancel-switch" onclick="app.cancelSwitch()">戻る</button>
        </div>

        <!-- Result Screen -->
        <div id="screen-result" class="screen">
            <h2>ターン結果</h2>
            <div class="battle-info">
                <!-- P1 Status -->
                <div style="text-align: left;">
                    <strong id="res-p1-name">P1</strong> (Lv.<span id="res-p1-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p1" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p1">100/100</span>
                </div>
                <!-- P2 Status -->
                <div style="text-align: right;">
                    <strong id="res-p2-name">P2</strong> (Lv.<span id="res-p2-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p2" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p2">100/100</span>
                </div>
            </div>

            <div class="log-box" id="battle-log"></div>
            <button class="btn" onclick="app.nextTurn()">次へ</button>
        </div>

        <!-- Game Over Screen -->
        <div id="screen-gameover" class="screen">
            <h1 id="gameover-title" style="color: #d32f2f;">Game Set!</h1>
            <h2 id="gameover-winner">Winner: Player X</h2>

            <div class="gameover-options">
                <button class="btn btn-blue" onclick="app.restartRandom()">もう一戦する (ランダム編成)</button>
                <button class="btn btn-blue" onclick="app.restartSame()">もう一戦する (同じ編成)</button>
                <button class="btn" onclick="app.restartManual()">ポケモンから組みなおす</button>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        //  CSV設定エリア (ここを変更してください)
        // ==========================================
        const CSV_DATA_EMBEDDED = ``;

        // Raw URL のパスは /<owner>/<repo>/<branch>/<path> の形式にする（refs/heads は不要）
        const CSV_DATA_URL = "https://raw.githubusercontent.com/K-626/pokemon/refs/heads/main/data.csv";

        // 自動読み込みを有効にするには "url" または "embed" に設定します
        // "url" -> CSV_DATA_URL から fetch
        // "embed" -> CSV_DATA_EMBEDDED に埋め込んだテキストを読み込む
        // "manual" -> ファイル入力のみ（今の挙動）
        const USE_CSV_SOURCE = "manual";
        // ==========================================

        // --- Constants & Config ---
        const TYPE_JP_TO_EN = {
            "ノーマル": "normal", "ほのお": "fire", "みず": "water", "くさ": "grass", "でんき": "electric",
            "こおり": "ice", "かくとう": "fighting", "どく": "poison", "じめん": "ground", "ひこう": "flying",
            "エスパー": "psychic", "むし": "bug", "いわ": "rock", "ゴースト": "ghost", "ドラゴン": "dragon",
            "あく": "dark", "はがね": "steel", "フェアリー": "fairy", "": "none"
        };

        const TYPE_CHART = {
            normal: { rock: 0.5, ghost: 0, steel: 0.5 },
            fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
            water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
            electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
            grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
            ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
            fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 },
            poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
            ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
            flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
            psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
            bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
            rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
            ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
            dragon: { dragon: 2, steel: 0.5, fairy: 0 },
            dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
            steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 },
            fairy: { fire: 0.5, fighting: 2, poison: 0.5, dragon: 2, dark: 2, steel: 0.5 },
            none: {}
        };

        // Custom Accuracy Table (Used when CSV cannot be modified)
        const CUSTOM_ACCURACY = {
            'おうふくビンタ': 85, 'れんぞくパンチ': 85, 'メガトンパンチ': 85,
            'しめつける': 90, 'たたきつける': 75, 'メガトンキック': 75,
            'とびげり': 95, 'まわしげり': 85, 'みだれづき': 85,
            'つのドリル': 30, 'とっしん': 85, 'ミサイルばり': 95,
            'うたう': 55, 'ちょうおんぱ': 55, 'ハイドロポンプ': 80,
            'ふぶき': 70, 'はかいこうせん': 90, 'じごくぐるま': 80,
            'しびれごな': 75, 'ねむりごな': 75, 'どくのこな': 75,
            'かみなり': 70, 'じわれ': 30, 'どくどく': 90,
            'さいみんじゅつ': 60, 'やどりぎのタネ': 90, 'いやなおと': 85,
            'きあいだま': 70, 'ダストシュート': 80, 'ストーンエッジ': 80,
            'じゃれつく': 90, 'ネズミざん': 90, 'かかとおとし': 90,
            'がんせきアックス': 90, 'みずあめボム': 85, 'シャカシャカほう': 90,
            'パワフルエッジ': 95
        };

        const NATURE_TABLE = {
            "1.0": { name: "補正なし", up: null, down: null },
            "adamant": { name: "いじっぱり", up: "atk", down: "spa" },
            "modest": { name: "ひかえめ", up: "spa", down: "atk" },
            "bold": { name: "ずぶとい", up: "def", down: "atk" },
            "timid": { name: "おくびょう", up: "spe", down: "atk" },
            "jolly": { name: "ようき", up: "spe", down: "spa" },
            "impish": { name: "わんぱく", up: "def", down: "spa" },
            "calm": { name: "おだやか", up: "spd", down: "atk" },
            "careful": { name: "しんちょう", up: "spd", down: "spa" },
        };

        const TYPE_EN_TO_JP = {};
        Object.keys(TYPE_JP_TO_EN).forEach(jp => {
            const en = TYPE_JP_TO_EN[jp];
            if (en !== 'none') TYPE_EN_TO_JP[en] = jp;
        });
        TYPE_EN_TO_JP['none'] = 'ー';

        const TEAM_SIZE = 3;
        const MOVES_COUNT = 4;

        // --- CSV Data Store ---
        let pokemonDB = {};
        let moveDB = {};

        // --- App State ---
        const app = {
            players: [],
            setupPlayerIndex: 0,
            turn: 0,
            turnActions: [],
            history: [],
            winner: null,
            weather: 'none',
            weatherTurns: 0,
            trickRoomTurns: 0,
            terrain: 'none',
            terrainTurns: 0,
            isSinglePlayer: false, // New flag for CPU mode
            endOfTurnStage: 0, // 0: not started, 1: damage processed, 2: completed

            // init: safer with element existence checks
            init: function () {
                // Pre-load Logic
                if (USE_CSV_SOURCE === "embed" && CSV_DATA_EMBEDDED.trim() !== "") {
                    this.parseCsv(CSV_DATA_EMBEDDED);
                    const uploadAreaEl = document.getElementById('upload-area');
                    if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "埋め込みデータをロードしました";
                } else if (USE_CSV_SOURCE === "url" && CSV_DATA_URL.trim() !== "") {
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "URLからデータを読み込んでいます...";
                    fetch(CSV_DATA_URL)
                        .then(res => {
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            return res.text();
                        })
                        .then(text => {
                            this.parseCsv(text);
                            const uploadAreaEl = document.getElementById('upload-area');
                            if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                            if (csvStatusEl) csvStatusEl.innerText = "WEBデータをロードしました";
                        })
                        .catch(err => {
                            console.error(err);
                            const csvStatusEl2 = document.getElementById('csv-status');
                            if (csvStatusEl2) csvStatusEl2.innerText = "読み込みエラー (手動アップロードを使用してください)";
                        });
                }
            },

            fetchDataFromUrl: function () {
                const POKE_URL = "https://raw.githubusercontent.com/K-626/pokemon/main/data.csv";
                const MOVE_URL = "https://raw.githubusercontent.com/K-626/pokemon/main/move.csv";

                const fetchOne = (url, type) => {
                    return fetch(url)
                        .then(res => {
                            if (!res.ok) throw new Error('Fetch failed: ' + url);
                            return res.text();
                        })
                        .then(text => {
                            if (type === 'pokemon') this.parseCsv(text);
                            else if (type === 'move') this.parseMoveCsv(text);
                        })
                        .catch(err => {
                            console.error(err);
                            alert("エラー: " + url + " の読み込みに失敗しました。URLが正しいか確認してください。");
                        });
                };

                Promise.all([fetchOne(POKE_URL, 'pokemon'), fetchOne(MOVE_URL, 'move')])
                    .then(() => {
                        const area = document.getElementById('upload-area');
                        if (area) area.style.backgroundColor = '#e8f5e9';
                    });
            },

            // --- CSV Logic ---
            handleCsvUpload: function (input, type) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (type === 'pokemon') this.parseCsv(e.target.result);
                    if (type === 'move') this.parseMoveCsv(e.target.result);
                };
                reader.readAsText(file);
            },

            parseMoveCsv: function (text) {
                // Determine headers automatically similar to pokemon csv
                if (!text) return;
                // BOM check
                if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

                const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== "");
                if (lines.length < 2) return;

                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const find = (keys) => headers.findIndex(h => keys.some(k => h.includes(k)));

                const idxName = find(['名前', 'name']);
                const idxType = find(['タイプ', 'type']);
                const idxCat = find(['分類', 'category', 'cat']);
                const idxPower = find(['威力', 'power']);
                const idxAcc = find(['命中', 'accuracy', 'acc']);
                const idxPriority = find(['優先度', 'priority', 'pri']);
                const idxEffect = find(['効果', 'effect']);

                if (idxName === -1) {
                    alert("技CSVエラー: 名前列が見つかりません");
                    return;
                }

                // Simple parser
                const splitRow = (row) => {
                    const res = []; let cur = ''; let q = false;
                    for (let c of row) {
                        if (c === '"') { q = !q; } else if (c === ',' && !q) { res.push(cur); cur = ''; } else { cur += c; }
                    }
                    res.push(cur); return res;
                };

                let count = 0;
                moveDB = {};
                for (let i = 1; i < lines.length; i++) {
                    const row = splitRow(lines[i]).map(s => s.trim().replace(/^"|"$/g, ''));
                    const name = row[idxName];
                    if (!name) continue;

                    const effStr = (idxEffect !== -1 && row[idxEffect]) ? row[idxEffect] : "";

                    moveDB[name] = {
                        name: name,
                        type: (idxType !== -1) ? (TYPE_JP_TO_EN[row[idxType]] || 'normal') : 'normal',
                        category: (idxCat !== -1 && (row[idxCat] === '変化' || row[idxCat] === 'status' || row[idxCat] === 'へんか')) ? 'status'
                            : (idxCat !== -1 && (row[idxCat] === '特殊' || row[idxCat] === 'special' || row[idxCat] === 'とくしゅ')) ? 'special' : 'physical',
                        power: (idxPower !== -1) ? (parseInt(row[idxPower]) || 0) : 0,
                        accuracy: (idxAcc !== -1) ? (parseInt(row[idxAcc]) || 100) : 100,
                        priority: (idxPriority !== -1) ? (parseInt(row[idxPriority]) || 0) : 0,
                        effect: this.parseMoveEffect(effStr + ` [NAME_STATUS:${name}]`)
                    };

                    // --- Name-based Overrides ---
                    const m = moveDB[name];
                    // Recoil
                    if (['とっしん', 'ワイルドボルト', 'じごくぐるま'].includes(name)) m.effect.meta.recoil = 0.25;
                    if (['すてみタックル', 'ウッドハンマー', 'フレアドライブ', 'ブレイブバード', 'ボルテッカー', 'ウェーブタックル'].includes(name)) m.effect.meta.recoil = 0.33;
                    if (['もろはのずつき'].includes(name)) m.effect.meta.recoil = 0.5;
                    if (['てっていこうせん'].includes(name)) m.effect.meta.recoilMaxHp = 0.5;

                    // Drain
                    const drains = ['むねんのつるぎ', 'すいとる', 'メガドレイン', 'ギガドレイン', 'ウッドホーン', 'シャカシャカほう', 'パラボラチャージ', 'きゅうけつ', 'デスウイング', 'ゆめくい', 'ドレインパンチ', 'ドレインキッス'];
                    if (drains.includes(name)) m.effect.meta.drain = 0.5;

                    // Curse & Endeavor
                    if (name === 'のろい') { m.effect.meta.curse = true; m.target = 'self_or_enemy'; } // Logic handled in resolveTurn
                    if (name === 'がむしゃら') { m.effect.meta.endeavor = true; }
                    if (['ボルトチェンジ', 'とんぼがえり', 'クイックターン'].includes(name)) m.effect.meta.switchingMove = true;

                    // New Move Flags (Set 2)
                    if (name === 'いたみわけ') { m.effect.meta.painSplit = true; m.target = 'enemy'; }
                    if (name === 'みらいよち' || name === 'Future Sight') { m.effect.meta.futureSight = true; }
                    if (name === 'ほろびのうた' || name === 'Perish Song') { m.effect.meta.perish = true; m.target = 'all'; }
                    if (name === 'はらだいこ' || name === 'Belly Drum') { m.effect.meta.bellyDrum = true; m.target = 'self'; }
                    if (name === 'ねむる' || name === 'Rest') { m.effect.meta.rest = true; m.target = 'self'; }

                    // New Move Flags (Set 3)
                    if (name === 'げきりん' || name === 'Outrage') { m.effect.meta.outrage = true; m.target = 'random'; } // Similar to Thrash
                    if (name === 'まねっこ' || name === 'Copycat') { m.effect.meta.copycat = true; m.target = 'self'; }
                    if (name === 'ゆびをふる' || name === 'Metronome') { m.effect.meta.metronome = true; m.target = 'self'; }
                    if (name === 'ひかりのかべ' || name === 'Light Screen') { m.effect.meta.lightScreen = true; m.target = 'self'; }
                    if (name === 'リフレクター' || name === 'Reflect') { m.effect.meta.reflect = true; m.target = 'self'; }
                    if (name === 'じこあんじ' || name === 'Psych Up') { m.effect.meta.psychUp = true; m.target = 'enemy'; }
                    if (name === 'アシストパワー' || name === 'Stored Power') { m.effect.meta.storedPower = true; }
                    if (name === 'しおふき' || name === 'ふんか' || name === 'Water Spout' || name === 'Eruption') {
                        m.effect.variablePower = { type: 'hp_high' };
                    }

                    // Fixed Power 80 (Weight/Speed based moves)
                    const fixed80 = ['ヘビーボンバー', 'ヒートスタンプ', 'ジャイロボール', 'エレキボール', 'くさむすび', 'けたぐり'];
                    if (fixed80.includes(name)) {
                        m.power = 80;
                        m.effect.variablePower = null; // Clear if set
                    }

                    // Protection
                    const protects = ['まもる', 'みきり', 'トーチカ', 'ブロッキング', 'ニードルガード', 'たたみがえし', 'キングシールド', 'トリックガード', 'スレッドトラップ', 'かえんのまもり'];
                    if (protects.includes(name)) {
                        m.priority = 4;
                        m.effect.meta.protect = true;
                        if (name === 'トーチカ') m.effect.meta.protectEffect = 'psn';
                        if (name === 'ニードルガード') m.effect.meta.protectEffect = 'dmg_1/8';
                        if (name === 'キングシールド') m.effect.meta.protectEffect = 'atk_-1';
                        if (name === 'ブロッキング') m.effect.meta.protectEffect = 'def_-2';
                        if (name === 'スレッドトラップ') m.effect.meta.protectEffect = 'spe_-1';
                        if (name === 'かえんのまもり') m.effect.meta.protectEffect = 'brn';
                    }

                    // Priority Moves (Requested)
                    const p3 = ['ねこだまし'];
                    const p2 = ['しんそく', 'フェイント', 'であいがしら'];
                    const p1 = ['マッハパンチ', 'バレットパンチ', 'でんこうせっか', 'アクアジェット', 'かげうち', 'ふいうち', 'こおりのつぶて', 'しんくうは', 'みずしゅりけん', 'アクセルロック', 'ジェットパンチ'];

                    if (p3.includes(name)) m.priority = 3;
                    else if (p2.includes(name)) m.priority = 2;
                    else if (p1.includes(name)) m.priority = 1;

                    // Substitute & Hazards
                    if (name === '身代わり') m.effect.meta.substitute = true;
                    if (name === 'まきびし') m.effect.meta.hazard = 'spikes';
                    if (name === 'ステルスロック') m.effect.meta.hazard = 'rocks';
                    if (name === 'どくびし') m.effect.meta.hazard = 'tspikes';

                    // Charge Moves
                    const chargeMoves = [
                        'かまいたち', 'ロケットずつき', 'ゴッドバード', 'フリーズボルト', 'コールドフレア',
                        'ソーラーブレード', 'ジオコントロール', 'メテオビーム', 'ソーラービーム',
                        'あなをほる', 'そらをとぶ', 'ダイビング', 'とびはねる', 'シャドーダイブ', 'ゴーストダイブ'
                    ];
                    if (chargeMoves.includes(name)) m.effect.meta.charge = true;
                    if (name === 'ロケットずつき') { m.effect.meta.chargeEffect = 'def_+1'; m.effect.statChanges = []; }
                    if (name === 'メテオビーム') { m.effect.meta.chargeEffect = 'spa_+1'; m.effect.statChanges = []; }

                    if (name === 'あなをほる') m.effect.meta.startInvulnerable = 'dig';
                    if (name === 'そらをとぶ') m.effect.meta.startInvulnerable = 'fly';
                    if (name === 'とびはねる') m.effect.meta.startInvulnerable = 'bounce';
                    if (name === 'ダイビング') m.effect.meta.startInvulnerable = 'dive';
                    if (name === 'シャドーダイブ') m.effect.meta.startInvulnerable = 'shadow';
                    if (name === 'ゴーストダイブ') m.effect.meta.startInvulnerable = 'phantom';

                    // OHKO Moves (Explicit)
                    const ohkoMoves = ['じわれ', 'つのドリル', 'ハサミギロチン', 'ぜったいれいど'];
                    if (ohkoMoves.includes(name)) m.effect.meta.ohko = true;

                    // Recharge Moves
                    const recharges = [
                        'ギガインパクト', 'はかいこうせん', 'ブラストバーン', 'ハイドロカノン',
                        'ハードプラント', 'スターアサルト', 'プリズムレーザー', 'がんせきほう',
                        'ときのほうこう', 'ムゲンダイビーム'
                    ];
                    if (recharges.includes(name)) m.effect.meta.recharge = true;

                    // --- Weather Moves ---
                    if (name === 'あまごい') m.effect.meta.weather = 'rain';
                    if (name === 'にほんばれ') m.effect.meta.weather = 'sun';
                    if (name === 'すなあらし') m.effect.meta.weather = 'sandstorm';
                    if (name === 'あられ' || name === 'ゆきげしき') m.effect.meta.weather = 'snow';

                    // --- Recovery Moves ---
                    const heal50 = ['じこさいせい', 'たまごうみ', 'ミルクのみ', 'なまける', 'はねやすめ', 'かいふくしれい'];
                    if (heal50.includes(name)) m.effect.meta.heal = 0.5;

                    const healWeather = ['つきのひかり', 'あさのひざし', 'こうごうせい'];
                    if (healWeather.includes(name)) m.effect.meta.heal = 'weather';

                    // --- Trapping Moves (Bind) ---
                    const traps = ['しめつける', 'まきつく', 'ほのおのうず', 'うずしお', 'すなじごく', 'まとわりつく', 'マグマストーム', 'サンダープリズン'];
                    if (traps.includes(name)) {
                        m.effect.meta.trap = true;
                        m.effect.meta.trapName = name;
                    }

                    // --- Field Moves ---
                    if (['エレキフィールド', 'グラスフィールド', 'ミストフィールド', 'サイコフィールド'].includes(name)) {
                        const map = { 'エレキフィールド': 'electric', 'グラスフィールド': 'grassy', 'ミストフィールド': 'misty', 'サイコフィールド': 'psychic' };
                        m.effect.meta.field = map[name];
                    }
                    if (name === 'トリックルーム') m.effect.meta.trickroom = true;
                    if (name === 'どろぼう' || name === 'ほしがる') m.effect.meta.steal = true;
                    if (name === 'トリック' || name === 'すりかえ') m.effect.meta.swapItem = true;
                    if (name === 'バトンタッチ') { m.effect.meta.batonPass = true; m.category = 'status'; }
                    if (name === 'ゆめくい') { m.effect.meta.dreamEater = true; m.effect.meta.drain = 0.5; }
                    if (name === 'へんしん') { m.effect.meta.transform = true; m.category = 'status'; }
                    if (name === 'ふういん') { m.effect.meta.imprison = true; m.category = 'status'; }
                    if (name === 'もえつきる') m.effect.meta.burnUp = true;
                    if (name === 'ほろびのうた' || name === 'Perish Song') { m.effect.meta.perishMove = true; m.target = 'all'; m.category = 'status'; }
                    if (name === 'ねこのて' || name === 'Assist') { m.effect.meta.assist = true; m.target = 'self'; m.category = 'status'; }

                    // Status moves should usually have 100% status chance
                    if (m.category === 'status' && m.effect.meta.status) {
                        m.effect.meta.statusChance = 100;
                    }

                    count++;
                }
                const st = document.getElementById('csv-status-move');
                if (st) st.innerText = `技データ: ${count}件ロード完了`;
                console.log('MoveDB loaded:', count);

                // Add to datalist if exists
                let dl = document.getElementById('move-list');
                if (!dl) {
                    dl = document.createElement('datalist');
                    dl.id = 'move-list';
                    document.body.appendChild(dl);
                }
                dl.innerHTML = '';
                Object.keys(moveDB).forEach(k => {
                    const op = document.createElement('option');
                    op.value = k;
                    dl.appendChild(op);
                });
            },

            /**
             * 技の「効果」テキストを解析し、構造化されたメタデータに変換します。
             * @param {string} str CSVの「効果」列の文字列
             * @returns {Object} { meta: {status, statusChance, recoil, ...}, statChanges: [...], flags: {alwaysHit, ...} }
             */
            parseMoveEffect: function (str) {
                // Parse the "Effect" column based on user rules
                const res = {
                    meta: {},
                    flags: {},
                    variablePower: null // { type: 'weight'|'hp_high'|'hp_low'|'speed_slow'|'speed_fast' }
                };
                if (!str) return res;

                // 2. State Assign
                if (str.match(/poison/i) || str.includes('どく')) { res.meta.status = 'psn'; res.meta.statusChance = 30; }
                if (str.match(/paralyze/i) || str.includes('まひ')) { res.meta.status = 'par'; res.meta.statusChance = 30; }
                if (str.match(/burn/i) || str.includes('やけど')) { res.meta.status = 'brn'; res.meta.statusChance = 30; }
                if (str.match(/freeze/i) || str.includes('こおり')) { res.meta.status = 'frz'; res.meta.statusChance = 10; }
                if (str.match(/confuse/i) || str.includes('混乱')) { res.meta.confuse = true; res.meta.confuseChance = 30; }
                if (str.match(/sleep/i) || str.includes('眠り')) { res.meta.status = 'slp'; res.meta.statusChance = 100; }

                // Refine chance based on text
                if (str.match(/10%/)) res.meta.statusChance = 10;
                else if (str.match(/20%/)) res.meta.statusChance = 20;
                else if (str.match(/30%/)) res.meta.statusChance = 30;
                else if (str.match(/50%/)) res.meta.statusChance = 50;
                else if (str.match(/100%/)) res.meta.statusChance = 100;

                // --- Status by Move Name (Strict) ---
                if (str.includes('[NAME_STATUS]')) {
                    const nameMatch = str.match(/\[NAME_STATUS:(.*)\]/);
                    if (nameMatch) {
                        const mName = nameMatch[1];
                        if (['でんじは', 'へびにらみ', 'しびれごな'].includes(mName)) { res.meta.status = 'par'; res.meta.statusChance = 100; }
                        if (['どくどく', 'どくのこな'].includes(mName)) { res.meta.status = 'psn'; res.meta.statusChance = 100; }
                        if (['おにび'].includes(mName)) { res.meta.status = 'brn'; res.meta.statusChance = 100; }
                        if (['ねむりごな', 'キノコのほうし', 'さいみんじゅつ', 'あくび'].includes(mName)) { res.meta.status = 'slp'; res.meta.statusChance = 100; }
                    }
                }

                // 3. Flinch
                if (str.match(/flinch/i) || str.includes('ひるみ')) { res.meta.flinchChance = 30; }

                // 4. Stats (Enhanced)
                res.statChanges = [];
                const statMap = {
                    'special attack': 'spa', 'special defense': 'spd',
                    'attack': 'atk', 'defense': 'def', 'sp. atk': 'spa', 'sp. def': 'spd', 'speed': 'spe', 'evasion': 'eva',
                    '攻撃': 'atk', '防御': 'def', '特攻': 'spa', '特防': 'spd', '素早さ': 'spe', '回避率': 'eva'
                };

                const checkStat = (s) => {
                    let target = 'self';
                    let stage = 0;
                    if (s.match(/raises (?:the )?user's/i) || s.includes('自分の')) target = 'self';
                    if (s.match(/lowers (?:the )?target's/i) || s.includes('相手の')) target = 'enemy';

                    let statKey = null;
                    const keys = Object.keys(statMap).sort((a, b) => b.length - a.length);
                    for (const k of keys) {
                        if (s.toLowerCase().includes(k)) {
                            statKey = statMap[k];
                            break;
                        }
                    }
                    if (!statKey) return;

                    if (s.match(/sharply raises/i) || s.match(/by two stages/i) || s.includes('ぐーんと上が') || s.includes('2段階')) stage = 2;
                    else if (s.match(/drastically raises/i) || s.match(/by three stages/i) || s.includes('3段階')) stage = 3;
                    else if (s.match(/raises/i) || s.includes('上がる')) stage = 1;
                    else if (s.match(/harshly lowers/i) || s.match(/by two stages/i) || s.includes('がくっと下が')) stage = -2;
                    else if (s.match(/severely lowers/i) || s.match(/by three stages/i)) stage = -3;
                    else if (s.match(/lowers/i) || s.includes('下がる')) stage = -1;

                    if (stage !== 0) {
                        res.statChanges.push({ target, stat: statKey, stage });
                    }
                };
                checkStat(str);

                if (str.match(/Raises the user's/i) || str.includes('自分の能力を上げ')) {
                    if (res.statChanges.length === 0) res.meta.statSelf = true;
                }

                // 5. High Crit
                if (str.match(/high critical/i) || str.includes('急所')) { res.meta.critRate = 2; }

                // 6. Never Miss
                if (str.match(/never miss/i) || str.includes('必中')) { res.flags.alwaysHit = true; }

                // 7. Multi Hit
                if (str.match(/Hits 2–5 times/i)) { res.multihit = [2, 5]; }
                if (str.match(/Hits twice/i) || str.includes('2回連続')) { res.multihit = [2, 2]; }
                if (str.includes('ネズミざん') || str.match(/Hits 1–10 times/i)) { res.multihit = [1, 10]; }

                // 8. Recoil
                if (str.match(/recoil/i) || str.includes('反動')) { res.meta.recoil = 0.25; }

                // 9. Drain
                if (str.match(/recovers.*damage/i) || str.includes('吸収')) { res.meta.drain = 0.5; }

                // 10. OHKO
                if (str.match(/One-hit KO/i) || str.includes('一撃必殺') || str.includes('一撃でひんしになる')) { res.meta.ohko = true; }

                // 11. Weather
                // 11. Weather (Strictly Name Parsing Only - see parseMoveCsv overrides or handle here by name)
                // Removed loose description matching as requested.
                // if (str.match(/sunny/i) || str.includes('にほんばれ')) { res.meta.weather = 'sun'; }
                // if (str.match(/rain/i) || str.includes('あまごい')) { res.meta.weather = 'rain'; }
                // if (str.match(/sandstorm/i) || str.includes('すなあらし')) { res.meta.weather = 'sandstorm'; }
                // if (str.match(/snow/i) || str.includes('ゆきげしき')) { res.meta.weather = 'snow'; }

                // 12. Fixed Damage
                const fixed = str.match(/Inflicts (\d+) damage/i);
                if (fixed) { res.fixedDamage = parseInt(fixed[1]); }

                // 13. New Mechanics (Heal, Self-Faint, Recharge)
                if (str.match(/Restores the user's HP/i) || str.includes('回復')) { res.meta.heal = 0.5; }
                if (str.match(/user faints/i) || str.includes('自分はひんし')) { res.meta.selfFaint = true; }
                if (str.match(/must recharge/i) || str.includes('動けなくなる')) { res.meta.recharge = true; }

                // 14. Variable Power Moves
                // 14. Variable Power Moves
                // Removed standard parsing for these to force 80 power later, or manually set them.
                // Keeping HP based ones if they are not part of the "Fixed 80" request.
                // The request said: "Change those that vary by weight/speed to fixed 80".
                // So we remove detection for weight/speed.

                // if (str.match(/heavier the target/i)) { res.variablePower = { type: 'weight' }; }
                if (str.match(/lower the user's HP/i)) { res.variablePower = { type: 'hp_low' }; }
                if (str.match(/higher the user's HP/i)) { res.variablePower = { type: 'hp_high' }; }
                // if (str.match(/slower the user/i)) { res.variablePower = { type: 'speed_slow' }; }
                // if (str.match(/faster the user/i)) { res.variablePower = { type: 'speed_fast' }; }

                // 15. Manual Flags (Field/TR)
                if (str.includes('エレキフィールド') || str.match(/Electric Terrain/i)) res.meta.field = 'electric';
                if (str.includes('グラスフィールド') || str.match(/Grassy Terrain/i)) res.meta.field = 'grassy';
                if (str.includes('ミストフィールド') || str.match(/Misty Terrain/i)) res.meta.field = 'misty';
                if (str.includes('サイコフィールド') || str.match(/Psychic Terrain/i)) res.meta.field = 'psychic';
                if (str.includes('トリックルーム') || str.match(/Trick Room/i)) res.meta.trickroom = true;

                // 15. Manual Flags (Field/TR) - handled in parseMoveCsv mostly but regex here if needed
                if (str.includes('エレキフィールド') || str.match(/Electric Terrain/i)) res.meta.field = 'electric';
                if (str.includes('グラスフィールド') || str.match(/Grassy Terrain/i)) res.meta.field = 'grassy';
                if (str.includes('ミストフィールド') || str.match(/Misty Terrain/i)) res.meta.field = 'misty';
                if (str.includes('サイコフィールド') || str.match(/Psychic Terrain/i)) res.meta.field = 'psychic';
                if (str.includes('トリックルーム') || str.match(/Trick Room/i)) res.meta.trickroom = true;

                return res;
            },

            parseCsv: function (text) {
                // BOM除去
                if (text && text.charCodeAt && text.charCodeAt(0) === 0xFEFF) {
                    console.log('BOM detected and removed');
                    text = text.slice(1);
                }

                if (!text || typeof text !== 'string') {
                    console.warn('parseCsv: invalid text');
                    return;
                }

                // 改行で分割して空行除去
                const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== "");
                console.log('lines:', lines.length);

                if (lines.length < 2) {
                    console.warn('CSV: 行数不足');
                    const csvStatusEl = document.getElementById('csv-status-poke');
                    if (csvStatusEl) csvStatusEl.innerText = "CSVの行数が不足しています";
                    return;
                }

                // ヘッダー行を取得して表示
                const rawHeaders = lines[0].split(',').map(h => h.trim());
                console.log('raw headers:', rawHeaders);

                // ヘッダー正規化ヘルパー（全角括弧→半角、空白削除、小文字化）
                const normalize = (s) => (s || '').replace(/（/g, '(').replace(/）/g, ')').replace(/\s/g, '').toLowerCase();
                const normHeaders = rawHeaders.map(h => normalize(h));
                console.log('normalized headers:', normHeaders);

                // 緩いマッチでヘッダーのインデックスを探す
                // 厳密なマッチでヘッダーのインデックスを探す
                const findHeader = (candidates) => {
                    for (let i = 0; i < normHeaders.length; i++) {
                        for (let c of candidates) {
                            if (normHeaders[i] === normalize(c)) return i;
                        }
                    }
                    return -1;
                };

                const idxName = findHeader(['名前(日本語)', '名前（日本語）', '名前']);
                const idxHP = findHeader(['HP']);
                const idxAtk = findHeader(['攻撃', '攻']);
                const idxDef = findHeader(['防御', '防']);
                const idxSpA = findHeader(['特攻', '特']);
                const idxSpD = findHeader(['特防', '特防御']);
                const idxSpe = findHeader(['素早さ', '素早']);
                const idxT1 = findHeader(['タイプ1', 'タイプ１', 'タイプ']);
                const idxT2 = findHeader(['タイプ2', 'タイプ２']);

                console.log({ idxName, idxHP, idxAtk, idxDef, idxSpA, idxSpD, idxSpe, idxT1, idxT2 });

                if (idxName === -1 || idxHP === -1) {
                    const available = rawHeaders.join(', ');
                    alert("CSVヘッダーエラー: 必須列(名前/HP)が見つかりませんでした。\n検出ヘッダー: " + available);
                    const csvStatusEl = document.getElementById('csv-status-poke');
                    if (csvStatusEl) csvStatusEl.innerText = "ヘッダーエラー: 名前/HP 列が見つかりません";
                    return;
                }

                // 簡易CSVパーサ（"で囲まれたフィールド内のカンマに対応）
                const splitCsvRow = (row) => {
                    const res = [];
                    let cur = '';
                    let inQuotes = false;
                    for (let i = 0; i < row.length; i++) {
                        const ch = row[i];
                        if (ch === '"') {
                            if (inQuotes && row[i + 1] === '"') {
                                cur += '"'; i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (ch === ',' && !inQuotes) {
                            res.push(cur);
                            cur = '';
                        } else {
                            cur += ch;
                        }
                    }
                    res.push(cur);
                    return res;
                };

                let count = 0;
                pokemonDB = {};
                const listEl = document.getElementById('pokemon-list');
                if (listEl) listEl.innerHTML = '';

                for (let i = 1; i < lines.length; i++) {
                    const row = splitCsvRow(lines[i]).map(c => c.trim());
                    // 名前とHPが存在するかを確認（柔軟に扱う）
                    const name = (typeof row[idxName] !== 'undefined') ? row[idxName] : '';
                    const hpVal = (typeof row[idxHP] !== 'undefined') ? row[idxHP] : '';

                    if (!name || !hpVal) {
                        // スキップ前にログ
                        console.debug(`skip row ${i + 1}: name or HP missing`, { name, hpVal, row });
                        continue;
                    }

                    // タイプ列が存在しなければ空文字にする
                    const t1raw = (idxT1 !== -1) ? (row[idxT1] || '') : '';
                    const t2raw = (idxT2 !== -1) ? (row[idxT2] || '') : '';

                    pokemonDB[name] = {
                        hp: parseInt(hpVal) || 0,
                        atk: parseInt(row[idxAtk]) || 0,
                        def: parseInt(row[idxDef]) || 0,
                        spa: parseInt(row[idxSpA]) || 0,
                        spd: parseInt(row[idxSpD]) || 0,
                        spe: parseInt(row[idxSpe]) || 0,
                        t1: TYPE_JP_TO_EN[(t1raw || '').trim()] || "normal",
                        t2: TYPE_JP_TO_EN[(t2raw || '').trim()] || "none"
                    };

                    if (listEl) {
                        const op = document.createElement('option');
                        op.value = name;
                        listEl.appendChild(op);
                    }
                    count++;
                }

                console.log('pokemonDB entries:', count);
                const csvStatusEl = document.getElementById('csv-status-poke');
                if (csvStatusEl) csvStatusEl.innerText = `データ準備完了: ${count} 匹`;
            },

            autoFillStats: function (name, prefix) {
                const data = pokemonDB[name];
                if (data) {
                    const getEl = (id) => document.getElementById(id);
                    if (getEl(`${prefix}_base_h`)) getEl(`${prefix}_base_h`).value = data.hp;
                    if (getEl(`${prefix}_base_a`)) getEl(`${prefix}_base_a`).value = data.atk;
                    if (getEl(`${prefix}_base_b`)) getEl(`${prefix}_base_b`).value = data.def;
                    if (getEl(`${prefix}_base_c`)) getEl(`${prefix}_base_c`).value = data.spa;
                    if (getEl(`${prefix}_base_d`)) getEl(`${prefix}_base_d`).value = data.spd;
                    if (getEl(`${prefix}_base_s`)) getEl(`${prefix}_base_s`).value = data.spe;

                    if (getEl(`${prefix}_type1`)) getEl(`${prefix}_type1`).value = data.t1;
                    if (getEl(`${prefix}_type2`)) getEl(`${prefix}_type2`).value = data.t2;

                    this.updateRealStats(prefix);
                }
            },

            // --- Setup Logic ---
            startSetup: function (pIdx) {
                this.setupPlayerIndex = pIdx;
                this.showScreen('screen-setup');
                const setupTitleEl = document.getElementById('setup-title');
                if (setupTitleEl) setupTitleEl.innerText = `Player ${pIdx + 1} パーティ編成`;
                const btn = document.getElementById('btn-setup-next');
                if (btn) btn.innerText = (pIdx === 0) ? "次へ (Player 2へ交代)" : "バトル開始！";
                this.renderSetup(pIdx);
            },

            renderSetup: function (pIdx) {
                const container = document.getElementById('setup-container');
                if (!container) return;
                let html = '<div class="wrapper-setup">';
                html += `<div class="player-setup-col">`;

                // Omakase Button
                html += `<button class="btn btn-blue" style="margin-bottom:10px; background:#673AB7;" onclick="app.applyRandomTeamToUi(${pIdx})">★ おまかせ編成 (IV合計504) ★</button>`;

                html += `<div class="pokemon-tabs-nav">`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    html += `<button class="pokemon-tab ${i === 0 ? 'active' : ''}" onclick="app.switchSetupTab(${i})">Poke ${i + 1}</button>`;
                }
                html += `</div>`;

                for (let i = 0; i < TEAM_SIZE; i++) {
                    let display = i === 0 ? 'block' : 'none';
                    const prefix = `p${pIdx}_m${i}`;

                    html += `<div id="tab-${prefix}" class="tab-content" style="display:${display}">
                        <div class="input-group">
                            <label>ポケモン名 (自動入力対)</label>
                            <input type="text" id="${prefix}_name" list="pokemon-list" placeholder="例: フシギバナ" 
                                onchange="app.autoFillStats(this.value, '${prefix}')" value="">
                            
                            <div class="stat-row" style="margin-top:10px;">
                                <label>Type</label>
                                <select id="${prefix}_type1">${this.renderTypeOptions('normal')}</select>
                                <select id="${prefix}_type2">${this.renderTypeOptions('none', true)}</select>
                            </div>

                            <div class="stat-row">
                                <label>Lv</label><input type="number" id="${prefix}_lv" value="50" style="width:50px" oninput="app.updateRealStats('${prefix}')">
                                <label>性格</label>
                                <select id="${prefix}_nature" onchange="app.updateRealStats('${prefix}')">
                                    <option value="1.0">--</option>
                                    <option value="adamant">いじっぱり(A↑ C↓)</option>
                                    <option value="jolly">ようき(S↑ C↓)</option>
                                    <option value="modest">ひかえめ(C↑ A↓)</option>
                                    <option value="timid">おくびょう(S↑ A↓)</option>
                                    <option value="bold">ずぶとい(B↑ A↓)</option>
                                    <option value="impish">わんぱく(B↑ C↓)</option>
                                    <option value="calm">おだやか(D↑ A↓)</option>
                                    <option value="careful">しんちょう(D↑ C↓)</option>
                                </select>
                            </div>
                            <div class="stat-row">
                                <label>持ち物</label>
                                <select id="${prefix}_item">
                                    <option value="">なし</option>
                                    <option value="きあいのタスキ">きあいのタスキ(満タン耐え)</option>
                                    <option value="いのちのたま">いのちのたま(威力1.3倍/反動)</option>
                                    <option value="たべのこし">たべのこし(毎T回復)</option>
                                    <option value="ゴツゴツメット">ゴツゴツメット(接触ダメ)</option>
                                    <option value="こだわりハチマキ">こだわりハチマキ(A1.5倍/技固定)</option>
                                    <option value="こだわりメガネ">こだわりメガネ(C1.5倍/技固定)</option>
                                    <option value="こだわりスカーフ">こだわりスカーフ(S1.5倍/技固定)</option>
                                    <option value="とつげきチョッキ">とつげきチョッキ(D1.5倍/変化技不可)</option>
                                    <option value="ブーストエナジー">ブーストエナジー(能力上昇)</option>
                                    <option value="クリアチャーム">クリアチャーム(能力ダウン無効)</option>
                                    <option value="おんみつマント">おんみつマント(追加効果無効)</option>
                                    <option value="パンチグローブ">パンチグローブ(パンチ強化/非接触)</option>
                                    <option value="いかさまダイス">いかさまダイス(連続技安定)</option>
                                    <option value="じゃくてんほけん">じゃくてんほけん(弱点でAC大幅上昇)</option>
                                    <option value="だっしゅつボタン">だっしゅつボタン(被弾時交代)</option>
                                    <option value="レッドカード">レッドカード(被弾時相手交代)</option>
                                    <option value="ラムのみ">ラムのみ(状態異常回復)</option>
                                    <option value="オボンのみ">オボンのみ(HP回復)</option>
                                    <option value="カゴのみ">カゴのみ(眠り回復)</option>
                                    <option value="リンドのみ">リンドのみ(草半減)</option>
                                    <option value="オッカのみ">オッカのみ(炎半減)</option>
                                    <option value="イトケのみ">イトケのみ(水半減)</option>
                                    <option value="ソクノのみ">ソクノのみ(電半減)</option>
                                    <option value="ヤチェのみ">ヤチェのみ(氷半減)</option>
                                    <option value="ヨプのみ">ヨプのみ(闘半減)</option>
                                    <option value="ビアーのみ">ビアーのみ(毒半減)</option>
                                    <option value="シュカのみ">シュカのみ(地半減)</option>
                                    <option value="バコウのみ">バコウのみ(飛半減)</option>
                                    <option value="ウタンのみ">ウタンのみ(超半減)</option>
                                    <option value="タンガのみ">タンガのみ(虫半減)</option>
                                    <option value="ハバンのみ">ハバンのみ(龍半減)</option>
                                    <option value="カシブのみ">カシブのみ(霊半減)</option>
                                    <option value="ロゼルのみ">ロゼルのみ(妖半減)</option>
                                    <option value="アッキのみ">アッキのみ(物理被弾でB↑)</option>
                                    <option value="タラプのみ">タラプのみ(特殊被弾でD↑)</option>
                                    <option value="しろいハーブ">しろいハーブ(ダウン解除)</option>
                                    <option value="メンタルハーブ">メンタルハーブ(メロメロ等解除)</option>
                                    <option value="パワフルハーブ">パワフルハーブ(溜めなし)</option>
                                    <option value="ひかりのねんど">ひかりのねんど(壁延長)</option>
                                    <option value="あつぞこブーツ">あつぞこブーツ(罠無効)</option>
                                </select>
                            </div>
                            <div class="stat-row">
                                <strong>種 / 個 / 努 / 実</strong>
                            </div>
                            ${this.renderStatInput(prefix, 'h', 'HP')}
                            ${this.renderStatInput(prefix, 'a', '攻撃')}
                            ${this.renderStatInput(prefix, 'b', '防御')}
                            ${this.renderStatInput(prefix, 'c', '特攻')}
                            ${this.renderStatInput(prefix, 'd', '特防')}
                            ${this.renderStatInput(prefix, 's', '素早')}
                            
                            <hr>
                            <h4>技構成</h4>
                            ${this.renderMovesInput(prefix)}
                        </div>
                    </div>`;
                }
                html += `</div></div>`;
                container.innerHTML = html;
            },

            renderMovesInput: function (prefix) {
                let html = '<div class="move-grid">';
                for (let j = 0; j < MOVES_COUNT; j++) {
                    html += `<div class="input-group" style="margin-bottom:0; padding:5px;">
                        <input type="text" id="${prefix}_move${j}_name" list="move-list" placeholder="技名" onchange="app.autoFillMove(this, '${prefix}_move${j}')">
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <select id="${prefix}_move${j}_type" style="width:60px;">
                                ${this.renderTypeOptions('normal')}
                            </select>
                            <select id="${prefix}_move${j}_cat" style="width:50px;">
                                <option value="physical">物</option>
                                <option value="special">特</option>
                                <option value="status">変</option>
                            </select>
                            <input type="number" id="${prefix}_move${j}_pwr" value="0" placeholder="威" style="width:40px;">
                        </div>
                    </div>`;
                }
                html += '</div>';
                return html;
            },

            autoFillMove: function (input, prefix) {
                const val = input.value;
                if (!moveDB[val]) return;
                const m = moveDB[val];
                const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
                setVal(`${prefix}_type`, m.type);
                setVal(`${prefix}_cat`, m.category);
                setVal(`${prefix}_pwr`, m.power);
            },

            finishSetupStep: function () {
                this.savePlayerData(this.setupPlayerIndex);

                if (this.setupPlayerIndex === 0) {
                    if (this.isSinglePlayer) {
                        // CPU Auto Generation (Single Player)
                        const cpuData = this.generateRandomTeamData(1);
                        const team = [];
                        cpuData.forEach((d, i) => {
                            const poke = pokemonDB[d.name];
                            // Base stats fallback if name not found?
                            const base = poke ? { h: poke.hp, a: poke.atk, b: poke.def, c: poke.spa, d: poke.spd, s: poke.spe } : { h: 100, a: 100, b: 100, c: 100, d: 100, s: 100 };

                            const stats = this.calcStatsFromData(base, d.ivs, d.evs, 50, d.nature);

                            // Construct Move Objects
                            const moves = d.moves.map(mName => {
                                const m = moveDB[mName];
                                return m ? { name: mName, type: m.type, category: m.category, power: m.power } : { name: '-', type: 'normal', category: 'physical', power: 0 };
                            });

                            team.push({
                                name: d.name,
                                lv: 50,
                                stats: stats,
                                currentHp: stats.hp,
                                ranks: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 },
                                moves: moves,
                                types: poke ? [poke.t1, poke.t2] : ['normal', 'none'],
                                status: null,
                                item: d.item,
                                consumeItem: false,
                                substituteHP: 0,
                                chargingMove: null,
                                invulnerableState: null,
                                trapped: null,
                                recharge: false,
                                protectCount: 0,
                                isProtected: false
                            });
                            this.checkBoosterEnergy(team[team.length - 1]);
                        });

                        this.players[1] = {
                            name: "CPU",
                            team: team,
                            activeIdx: 0,
                            action: null
                        };
                        console.log("CPU Team Generated:", this.players[1]);

                        this.initializeBattle();
                        return;
                    }

                    this.showScreen('screen-curtain');
                    const curtainMsgEl = document.getElementById('curtain-msg');
                    if (curtainMsgEl) curtainMsgEl.innerText = "Player 1 セットアップ完了";
                    const curtainSubEl = document.getElementById('curtain-sub');
                    if (curtainSubEl) curtainSubEl.innerText = "Player 2 に交代してください。準備ができたらボタンを押してください。";
                    const btnCurtain = document.getElementById('btn-curtain-action');
                    if (btnCurtain) {
                        btnCurtain.onclick = () => {
                            this.startSetup(1);
                        };
                        btnCurtain.innerText = "Player 2 セットアップへ";
                    }
                } else {
                    this.initializeBattle();
                }
            },

            setGameMode: function (mode) {
                this.isSinglePlayer = (mode === 'cpu');
                console.log("Game Mode:", mode);
            },

            applyRandomTeamToUi: function (pIdx) {
                const data = this.generateRandomTeamData(pIdx);
                data.forEach((member, mIdx) => {
                    const prefix = `p${pIdx}_m${mIdx}`;

                    // Set Name
                    const nameInput = document.getElementById(`${prefix}_name`);
                    if (nameInput) {
                        nameInput.value = member.name;
                        this.autoFillStats(member.name, prefix);
                    }

                    // Set Nature
                    const natInput = document.getElementById(`${prefix}_nature`);
                    if (natInput) natInput.value = member.nature;

                    // Set Item
                    const itemInput = document.getElementById(`${prefix}_item`);
                    if (itemInput) itemInput.value = member.item;

                    // Set EVs
                    if (member.evs) {
                        const setEv = (k, v) => {
                            const el = document.getElementById(`${prefix}_ev_${k}`);
                            if (el) el.value = v;
                        };
                        setEv('h', member.evs.h);
                        setEv('a', member.evs.a);
                        setEv('b', member.evs.b);
                        setEv('c', member.evs.c);
                        setEv('d', member.evs.d);
                        setEv('s', member.evs.s);
                    }

                    // Set IVs
                    if (member.ivs) {
                        const setIv = (k, v) => {
                            const el = document.getElementById(`${prefix}_iv_${k}`);
                            if (el) el.value = v;
                        };
                        setIv('h', member.ivs.h);
                        setIv('a', member.ivs.a);
                        setIv('b', member.ivs.b);
                        setIv('c', member.ivs.c);
                        setIv('d', member.ivs.d);
                        setIv('s', member.ivs.s);
                    }

                    // Set Moves
                    member.moves.forEach((mv, j) => {
                        const mvInput = document.getElementById(`${prefix}_move${j}_name`);
                        if (mvInput) {
                            mvInput.value = mv;
                            this.autoFillMove(mvInput, `${prefix}_move${j}`);
                        }
                    });
                });
                for (let i = 0; i < TEAM_SIZE; i++) {
                    this.updateRealStats(`p${pIdx}_m${i}`);
                }
            },
            savePlayerData: function (pIdx) {
                let team = [];
                for (let m = 0; m < TEAM_SIZE; m++) {
                    const prefix = `p${pIdx}_m${m}`;
                    let stats = this.calcStats(prefix);
                    let moves = [];
                    for (let j = 0; j < 4; j++) {
                        const moveNameEl = document.getElementById(`${prefix}_move${j}_name`);
                        const moveTypeEl = document.getElementById(`${prefix}_move${j}_type`);
                        const moveCatEl = document.getElementById(`${prefix}_move${j}_cat`);
                        const movePwrEl = document.getElementById(`${prefix}_move${j}_pwr`);
                        moves.push({
                            name: moveNameEl ? moveNameEl.value || '-' : '-',
                            type: moveTypeEl ? moveTypeEl.value : 'normal',
                            category: moveCatEl ? moveCatEl.value : 'physical',
                            power: movePwrEl ? parseInt(movePwrEl.value) || 0 : 0
                        });
                    }
                    const nameEl = document.getElementById(`${prefix}_name`);
                    const lvEl = document.getElementById(`${prefix}_lv`);
                    const t1El = document.getElementById(`${prefix}_type1`);
                    const t2El = document.getElementById(`${prefix}_type2`);
                    team.push({
                        name: nameEl ? (nameEl.value || `Poke${m + 1}`) : `Poke${m + 1}`,
                        lv: lvEl ? parseInt(lvEl.value) || 50 : 50,
                        stats: stats,
                        currentHp: stats.hp,
                        ranks: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 },
                        moves: moves,
                        types: [
                            t1El ? t1El.value : 'normal',
                            t2El ? t2El.value : 'none'
                        ],
                        status: null, // { condition: 'brn'|'par'|'psn'|'slp'|'frz', turns: N }
                        item: document.getElementById(`${prefix}_item`) ? document.getElementById(`${prefix}_item`).value : ""
                    });
                }
                if (this.players.length <= pIdx) this.players[pIdx] = {};
                this.players[pIdx] = {
                    name: pIdx === 0 ? "Player 1" : "Player 2",
                    team: team,
                    activeIdx: 0,
                    action: null
                };
            },

            updateRealStats: function (prefix) {
                // Wait for DOM
                setTimeout(() => {
                    const s = this.calcStats(prefix);
                    const map = { h: 'hp', a: 'atk', b: 'def', c: 'spa', d: 'spd', s: 'spe' };
                    const set = (k) => {
                        const el = document.getElementById(`${prefix}_real_${k}`);
                        if (el) el.innerText = s[map[k]];
                    };
                    set('h'); set('a'); set('b'); set('c'); set('d'); set('s');
                }, 0);
            },

            renderStatInput: function (prefix, statKey, label) {
                return `<div class="stat-row">
                    <label>${label}</label>
                    <input type="number" id="${prefix}_base_${statKey}" placeholder="種" value="100" oninput="app.updateRealStats('${prefix}')">
                    <input type="number" id="${prefix}_iv_${statKey}" placeholder="個" value="31" oninput="app.updateRealStats('${prefix}')">
                    <input type="number" id="${prefix}_ev_${statKey}" placeholder="努" value="${statKey === 'a' || statKey === 's' ? 252 : 0}" oninput="app.updateRealStats('${prefix}')">
                    <span id="${prefix}_real_${statKey}" style="width:40px; text-align:center; background:#eee; padding:3px; border-radius:4px; font-weight:bold;">-</span>
                </div>`;
            },

            renderTypeOptions: function (selected, includeNone = false) {
                let opts = '';
                if (includeNone) opts += `<option value="none" ${selected === 'none' ? 'selected' : ''}>なし</option>`;
                Object.keys(TYPE_CHART).forEach(k => {
                    if (k !== 'none') {
                        const jp = TYPE_EN_TO_JP[k] || k;
                        opts += `<option value="${k}" ${k === selected ? 'selected' : ''}>${jp}</option>`;
                    }
                });
                return opts;
            },

            renderMovesInput: function (prefix) {
                let html = '<div class="move-grid">';
                for (let j = 0; j < MOVES_COUNT; j++) {
                    html += `<div class="input-group" style="margin-bottom:0; padding:5px;">
                        <input type="text" id="${prefix}_move${j}_name" list="move-list" placeholder="技名" onchange="app.autoFillMove(this, '${prefix}_move${j}')">
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <select id="${prefix}_move${j}_type" style="width:60px;">
                                ${this.renderTypeOptions('normal')}
                            </select>
                            <select id="${prefix}_move${j}_cat" style="width:50px;">
                                <option value="physical">物</option>
                                <option value="special">特</option>
                                <option value="status">変</option>
                            </select>
                            <input type="number" id="${prefix}_move${j}_pwr" value="0" placeholder="威" style="width:40px;">
                        </div>
                    </div>`;
                }
                html += '</div>';
                return html;
            },

            autoFillMove: function (input, prefix) {
                const val = input.value;
                if (!moveDB[val]) return;
                const m = moveDB[val];
                const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
                setVal(`${prefix}_type`, m.type);
                setVal(`${prefix}_cat`, m.category);
                setVal(`${prefix}_pwr`, m.power);
                // Can also store accuracy/effect hiddenly if needed, but we look up by name in battle anyway
            },

            switchSetupTab: function (tabIdx) {
                const prefixBase = `p${this.setupPlayerIndex}_m`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    const el = document.getElementById(`tab-${prefixBase}${i}`);
                    if (el) el.style.display = 'none';
                }
                const showEl = document.getElementById(`tab-${prefixBase}${tabIdx}`);
                if (showEl) showEl.style.display = 'block';
                const bts = document.querySelectorAll('.pokemon-tab');
                bts.forEach(b => b.classList.remove('active'));
                if (bts[tabIdx]) bts[tabIdx].classList.add('active');
            },

            // --- Battle Flow ---

            initializeBattle: function () {
                if (!this.players[0] || !this.players[1]) {
                    alert("エラー: プレイヤーデータが不足しています");
                    return;
                }
                this.turn = 0;
                this.weather = 'none';
                this.weatherTurns = 0;
                this.endOfTurnStage = 0;

                // --- Initialization for Hazards & Mechanics ---
                this.players.forEach(p => {
                    p.activeIdx = 0;
                    p.hazards = { spikes: 0, rocks: false, tspikes: 0 };
                    p.team.forEach(mon => {
                        mon.currentHp = mon.stats.hp;
                        mon.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                        mon.status = null;
                        // mon.item is already set by savePlayerData, do not overwrite!
                        mon.consumeItem = false;
                        mon.substituteHP = 0; // Initialize substitute HP
                        mon.chargingMove = null;
                        mon.invulnerableState = null;
                        mon.trapped = null; // { name: string, turns: number, sourceIdx: number }
                        mon.recharge = false;
                        mon.protectCount = 0;
                        mon.isProtected = false;
                        mon.cursed = false; // Reset curse
                        this.checkBoosterEnergy(mon);
                    });
                });

                this.updateHpDisplay();
                this.startTurnCycle();
            },

            startTurnCycle: function () {
                this.currentPlayerIndex = 0;
                this.gameActive = true;
                this.checkForcedSwitchStart();
            },

            curtainAction: function () {
                if (this.gameActive) {
                    this.startTurnInput();
                }
            },

            decideCpuAction: function () {
                const p = this.players[1];
                const activeMon = p.team[p.activeIdx];
                const opponent = this.players[0].team[this.players[0].activeIdx];

                // Delay to simulate thinking
                setTimeout(() => {
                    const moves = activeMon.moves;
                    const validMoves = [];

                    moves.forEach((m, idx) => {
                        if (!m.name || m.name === '-') return;
                        let score = 0;

                        if (m.category !== 'status') {
                            const dmgRes = this.calcDamage(activeMon, opponent, m);
                            score = dmgRes.damage;

                            // Boost super effective
                            if (dmgRes.typeEff > 1) score *= 1.3;
                            if (dmgRes.typeEff < 1) score *= 0.5;
                            if (dmgRes.typeEff === 0) score = -100; // Do not use immune moves
                        } else {
                            // Status Move Scoring
                            // Simple parsing for scoring purposes if not already pre-parsed in moveDB correctly
                            const effect = m.effect || (moveDB[m.name] ? this.parseMoveEffect(moveDB[m.name].Effect) : null);

                            if (!effect) {
                                score = 10;
                            } else {
                                // Apply Status (if opponent has none)
                                if (effect.meta.status && !opponent.status) {
                                    score = 50; // Higher than average damage move early on
                                    // Adjust for type immunity
                                    if (effect.meta.status === 'par' && (opponent.types.includes('electric') || opponent.types.includes('ground'))) score = -10;
                                    if (effect.meta.status === 'psn' && (opponent.types.includes('steel') || opponent.types.includes('poison'))) score = -10;
                                    if (effect.meta.status === 'brn' && opponent.types.includes('fire')) score = -10;
                                }

                                // Buffs (Self)
                                if (effect.statChanges) {
                                    effect.statChanges.forEach(sc => {
                                        if (sc.target === 'self' && sc.stage > 0) {
                                            const current = activeMon.ranks ? activeMon.ranks[sc.stat] : 0;
                                            if (current < 4) score += (30 * sc.stage);
                                        }
                                        if (sc.target === 'enemy' && sc.stage < 0) {
                                            const current = opponent.ranks ? opponent.ranks[sc.stat] : 0;
                                            if (current > -4) score += (25 * Math.abs(sc.stage));
                                        }
                                    });
                                }

                                // Weather/Terrain setters
                                if (effect.meta.weather && this.weather !== effect.meta.weather) score = 40;
                                if (effect.meta.terrain && this.terrain !== effect.meta.terrain) score = 40;

                                // Healing
                                if (effect.meta.heal && activeMon.currentHp < activeMon.stats.hp * 0.5) score = 60;
                            }
                        }

                        // Accuracy weighting
                        const acc = m.accuracy || 100;
                        if (acc > 0 && acc < 100) score *= (acc / 100);

                        validMoves.push({ idx, score });
                    });

                    if (validMoves.length > 0) {
                        validMoves.sort((a, b) => b.score - a.score);

                        // Pick best or 2nd best with high probability
                        const r = Math.random();
                        if (r < 0.85) {
                            bestMoveIdx = validMoves[0].idx;
                        } else if (validMoves.length > 1 && r < 0.95) {
                            bestMoveIdx = validMoves[1].idx;
                        } else {
                            bestMoveIdx = validMoves[Math.floor(Math.random() * validMoves.length)].idx;
                        }
                    }

                    this.registerMove(bestMoveIdx);
                }, 800);
            },

            decideCpuSwitch: function (isForced) {
                const p = this.players[1];
                const aliveIdx = p.team.findIndex((m, i) => m.currentHp > 0 && i !== p.activeIdx);

                if (aliveIdx !== -1) {
                    setTimeout(() => {
                        if (isForced) {
                            this.performForcedSwitch(aliveIdx);
                        } else {
                            this.registerMove(-1, aliveIdx);
                        }
                    }, 800);
                } else {
                    console.log("CPU has no pokemon left to switch to.");
                }
            },

            // --- Auto Select Logic (Omakase) ---
            getRandomPokemonTeam: function () {
                const candidates = Object.keys(pokemonDB);
                if (candidates.length === 0) return [];

                // Fisher-Yates shuffle for fairness
                const shuffled = [...candidates];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled.slice(0, TEAM_SIZE);
            },

            getRandomMoveSet: function (pokeName) {
                const movesKeys = Object.keys(moveDB);
                if (movesKeys.length === 0) return [];

                // Try to include at least one STAB move
                const poke = pokemonDB[pokeName];
                let stabMoves = [];
                let otherMoves = [];

                const englishRegex = /[a-zA-Z]/;

                movesKeys.forEach(mKey => {
                    const m = moveDB[mKey];
                    if (m.name === '-' || englishRegex.test(m.name)) return;
                    if (poke && (m.type === poke.t1 || m.type === poke.t2)) {
                        stabMoves.push(m.name);
                    } else {
                        otherMoves.push(m.name);
                    }
                });

                // Fisher-Yates shuffle helper
                const shuffle = (array) => {
                    for (let i = array.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [array[i], array[array[j]]] = [array[j], array[i]];
                    }
                };

                // Re-implementing selection with better shuffle
                const selected = [];
                if (stabMoves.length > 0) {
                    const r = Math.floor(Math.random() * stabMoves.length);
                    selected.push(stabMoves[r]);
                    stabMoves.splice(r, 1);
                }

                const pool = [...stabMoves, ...otherMoves];
                // Shuffle pool
                for (let i = pool.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pool[i], pool[j]] = [pool[j], pool[i]];
                }

                while (selected.length < 4 && pool.length > 0) {
                    selected.push(pool.pop());
                }

                // Fill with '-' if not enough
                while (selected.length < 4) selected.push('-');

                return selected;
            },

            getRandomItem: function () {
                const items = [
                    "きあいのタスキ", "いのちのたま", "たべのこし", "ゴツゴツメット",
                    "こだわりハチマキ", "こだわりメガネ", "こだわりスカーフ", "とつげきチョッキ",
                    "ブーストエナジー", "クリアチャーム", "おんみつマント", "パンチグローブ",
                    "いかさまダイス", "じゃくてんほけん", "だっしゅつボタン", "レッドカード",
                    "ラムのみ", "オボンのみ", "カゴのみ",
                    "アッキのみ", "タラプのみ", "しろいハーブ", "パワフルハーブ", "くろいへどろ"
                ];
                return items[Math.floor(Math.random() * items.length)];
            },

            generateRandomTeamData: function (pIdx) {
                const teamNames = this.getRandomPokemonTeam();
                const teamData = [];

                teamNames.forEach((name, i) => {
                    const pData = pokemonDB[name];
                    const moves = this.getRandomMoveSet(name);
                    const item = this.getRandomItem();
                    const natureKeys = Object.keys(NATURE_TABLE).filter(k => k !== '1.0');
                    const nature = natureKeys[Math.floor(Math.random() * natureKeys.length)];

                    // Assign EVs: sum must be 504.
                    const statsList = ['h', 'a', 'b', 'c', 'd', 's'];
                    const evs = { h: 0, a: 0, b: 0, c: 0, d: 0, s: 0 };
                    // Shuffle stats and pick first 2 for 252
                    const shuffledStats = statsList.sort(() => 0.5 - Math.random());
                    evs[shuffledStats[0]] = 252;
                    evs[shuffledStats[1]] = 252;

                    // Assign IVs: sum must be 504 for team -> 168 per mon -> 28 per stat
                    const ivs = { h: 28, a: 28, b: 28, c: 28, d: 28, s: 28 };

                    teamData.push({
                        name: name,
                        item: item,
                        nature: nature,
                        moves: moves,
                        evs: evs,
                        ivs: ivs
                    });
                });
                return teamData;
            },
            checkForcedSwitchStart: function () {
                const p = this.players[this.currentPlayerIndex];
                if (p.team[p.activeIdx].currentHp === 0) {
                    this.showSwitchScreen(true);
                } else {
                    if (this.isSinglePlayer) {
                        if (this.currentPlayerIndex === 1) {
                            this.decideCpuAction();
                        } else {
                            this.startTurnInput();
                        }
                    } else {
                        this.showCurtain();
                    }
                }
            },

            showCurtain: function () {
                this.showScreen('screen-curtain');
                const pName = this.players[this.currentPlayerIndex].name;
                const curtainMsgEl = document.getElementById('curtain-msg');
                if (curtainMsgEl) curtainMsgEl.innerText = `${pName} の番です`;
                const curtainSubEl = document.getElementById('curtain-sub');
                if (curtainSubEl) curtainSubEl.innerText = "相手に見えないようにPCを操作してください。";
                const btnCurtain = document.getElementById('btn-curtain-action');
                if (btnCurtain) btnCurtain.onclick = () => app.curtainAction();
                if (btnCurtain) btnCurtain.innerText = "操作を開始する";
            },

            startTurnInput: function () {
                this.showScreen('screen-input');
                const p = this.players[this.currentPlayerIndex];
                const activeMon = p.team[p.activeIdx];

                // Opponent Info
                const opponentIdx = 1 - this.currentPlayerIndex;
                const opP = this.players[opponentIdx];
                const opMon = opP.team[opP.activeIdx];

                const opponentInfoDiv = document.getElementById('input-opponent-info');
                if (!opponentInfoDiv) {
                    // Create if not exists (quick patching DOM)
                    const header = document.getElementById('input-player-header');
                    const div = document.createElement('div');
                    div.id = 'input-opponent-info';
                    div.className = 'battle-info';
                    div.style.background = '#ffebee'; // slightly different color
                    div.style.marginBottom = '5px';
                    header.after(div);
                    // Re-fetch
                }

                const opDiv = document.getElementById('input-opponent-info');
                if (opDiv) {
                    const statusMap = { brn: ' [火傷]', par: ' [麻痺]', psn: ' [毒]', slp: ' [眠り]', frz: ' [氷]' };
                    const opStatus = opMon.status ? statusMap[opMon.status.condition] : "";
                    const opPct = (opMon.currentHp / opMon.stats.hp) * 100;

                    opDiv.innerHTML = `
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <strong>相手: ${opMon.name}${opStatus}</strong>
                            <span>Lv.${opMon.lv}</span>
                        </div>
                        <div class="hp-bar-container">
                            <div class="hp-bar ${opPct < 20 ? 'hp-crit' : opPct < 50 ? 'hp-low' : ''}" style="width:${opPct}%"></div>
                        </div>
                        <div style="text-align:right; font-size:12px;">${opMon.currentHp}/${opMon.stats.hp}</div>
                    `;
                }

                const headerEl = document.getElementById('input-player-header');
                if (headerEl) headerEl.innerText = `${p.name}: ${activeMon.name} の行動`;
                const nameEl = document.getElementById('input-active-name');
                if (nameEl) {
                    const statusMap = { brn: ' [火傷]', par: ' [麻痺]', psn: ' [毒]', slp: ' [眠り]', frz: ' [氷]' };
                    const statusText = activeMon.status ? statusMap[activeMon.status.condition] : "";
                    nameEl.innerText = activeMon.name + statusText;
                }
                const hpTextEl = document.getElementById('input-hp-text');
                if (hpTextEl) hpTextEl.innerText = `${activeMon.currentHp}/${activeMon.stats.hp}`;

                const pct = (activeMon.currentHp / activeMon.stats.hp) * 100;
                const bar = document.getElementById('input-hp-bar');
                if (bar) {
                    bar.style.width = pct + '%';
                    this.setHpColor(bar, pct);
                }

                const ranksEl = document.getElementById('input-active-ranks');
                if (ranksEl) {
                    const r = activeMon.ranks || { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                    const labels = { atk: '攻', def: '防', spa: '特攻', spd: '特防', spe: '素', acc: '命', eva: '回' };
                    let txt = [];
                    ['atk', 'def', 'spa', 'spd', 'spe', 'acc', 'eva'].forEach(k => {
                        const val = r[k];
                        if (val !== 0) {
                            txt.push(`${labels[k]}${val > 0 ? '+' : ''}${val}`);
                        }
                    });
                    ranksEl.innerText = txt.length > 0 ? txt.join(" ") : "ランク変化なし";
                }

                // Weather Indicator update
                const weatherEl = document.getElementById('weather-indicator');
                if (weatherEl) {
                    const wMap = { none: 'なし', sun: '晴れ', rain: '雨', sandstorm: '砂あらし', snow: '雪' };
                    weatherEl.innerText = `天候: ${wMap[this.weather]}`;
                    weatherEl.style.backgroundColor = this.weather === 'none' ? '#fff' : '#fff9c4';

                    // Field/TR Status append
                    const trStatus = this.trickRoomTurns > 0 ? ' [トリル]' : '';
                    const fieldMap = { none: '', electric: ' [エレキ]', grassy: ' [グラス]', misty: ' [ミスト]', psychic: ' [サイコ]' };
                    const fieldStatus = fieldMap[this.terrain] || '';
                    if (trStatus || fieldStatus) {
                        weatherEl.innerText += fieldStatus + trStatus;
                    }
                }

                const container = document.getElementById('move-buttons');
                if (container) {
                    container.innerHTML = '';

                    activeMon.moves.forEach((m, idx) => {
                        if (!m.name || m.name === '-') return;
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-move';
                        const typeJp = TYPE_EN_TO_JP[m.type] || m.type;
                        btn.innerHTML = `<strong>${m.name}</strong><br>${typeJp} / ${m.category === 'status' ? '-' : m.power}`;
                        btn.onclick = () => this.registerMove(idx);
                        container.appendChild(btn);
                    });

                    // Show Current Item BELOW moves
                    const itemEl = document.createElement('div');
                    itemEl.style.gridColumn = 'span 2'; // span across both columns
                    itemEl.style.marginTop = '10px';
                    itemEl.style.padding = '5px 10px';
                    itemEl.style.background = '#f5f5f5';
                    itemEl.style.border = '1px solid #ddd';
                    itemEl.style.borderRadius = '5px';
                    itemEl.style.fontSize = '12px';
                    itemEl.style.textAlign = 'center';
                    itemEl.innerHTML = `持ち物: ${activeMon.item || 'なし'}`;
                    container.appendChild(itemEl);
                }
            },

            registerMove: function (moveIdx, switchIdx = null) {
                const player = this.players[this.currentPlayerIndex];
                if (moveIdx === -1 && switchIdx !== null) {
                    player.action = { type: 'switch', switchIdx: switchIdx };
                } else {
                    player.action = { type: 'move', moveIdx: moveIdx };
                }

                if (this.currentPlayerIndex === 0) {
                    this.currentPlayerIndex = 1;
                    this.checkForcedSwitchStart();
                } else {
                    this.resolveTurn();
                }
            },

            resetTurnActions: function () {
                this.players.forEach(p => p.action = null);
                this.currentPlayerIndex = 0;
            },

            /**
             * ターンの全アクションを順序立てて実行します。
             * 処理順: 1. 行動順の決定 -> 2. 状態異常チェック -> 3. 行動実行 (命中判定等) -> 4. ダメージ・追加効果
             */
            resolveTurn: function () {
                this.showScreen('screen-result');
                const btn = document.querySelector('#screen-result button');
                if (btn) btn.disabled = true;
                const p1 = this.players[0];
                const p2 = this.players[1];

                // ログ初期化とターン数カウント
                const logBox = document.getElementById('battle-log');
                logBox.innerText = `--- ターン ${++this.turn} ---\n`;
                this.endOfTurnStage = 0;

                this.turnQueue = [];

                let p1Act = p1.action;
                let p2Act = p2.action;

                // --- 1. 行動順の計算 (Priority & Speed) ---
                // スピード計算 (ランク補正 + スカーフ + 麻痺補正)
                const getSpeed = (p) => {
                    const mon = p.team[p.activeIdx];
                    let s = mon.stats.spe * this.getRankMultiplier(mon.ranks ? mon.ranks.spe : 0);
                    if (mon.item === 'choice_scarf') s *= 1.5;
                    if (mon.status && mon.status.condition === 'par') s *= 0.5;
                    return Math.floor(s);
                };
                let p1Speed = getSpeed(p1);
                let p2Speed = getSpeed(p2);

                // 優先度判定: 入れ替え(6) > 技の優先度(神速等) > 素早さ
                const getPriority = (p) => {
                    const act = p.action;
                    if (act.type === 'switch') return 6;
                    const mon = p.team[p.activeIdx];
                    const move = mon.moves[act.moveIdx];
                    const moveData = moveDB[move.name] || move;
                    // Grassy Glide Priority
                    if (move.name === 'グラススライダー' && this.terrain === 'grassy') {
                        // Check grounded
                        if (!mon.types.includes('flying')) return 1;
                    }
                    if (moveData.name === 'トリックルーム') return -7;
                    return moveData.priority || 0;
                };

                let p1Pri = getPriority(p1);
                let p2Pri = getPriority(p2);

                let order = [];
                if (p1Pri > p2Pri) order = [0, 1];
                else if (p2Pri > p1Pri) order = [1, 0];
                else {
                    // Trick Room Speed Reversal
                    if (this.trickRoomTurns > 0) {
                        order = (p1Speed >= p2Speed) ? [1, 0] : [0, 1];
                    } else {
                        order = (p1Speed >= p2Speed) ? [0, 1] : [1, 0];
                    }
                }

                // Simulation State (so we know if someone fainted mid-turn)
                const simState = [
                    { currentHp: p1.team[p1.activeIdx].currentHp },
                    { currentHp: p2.team[p2.activeIdx].currentHp }
                ];
                let simActiveIdx = [p1.activeIdx, p2.activeIdx];

                order.forEach(actorIdx => {
                    const targetIdx = 1 - actorIdx;
                    const actorP = this.players[actorIdx];
                    const targetP = this.players[targetIdx];
                    let act = actorP.action;

                    // Dead check
                    if (simState[actorIdx].currentHp <= 0) return;

                    const attacker = actorP.team[simActiveIdx[actorIdx]];
                    const defender = targetP.team[simActiveIdx[targetIdx]];

                    // --- Charge Move Override ---
                    if (attacker.chargingMove) {
                        const mIdx = attacker.moves.findIndex(m => m.name === attacker.chargingMove);
                        if (mIdx !== -1) act = { type: 'move', moveIdx: mIdx };
                    }

                    // --- Recharge Check ---
                    if (attacker.recharge) {
                        this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 反動で 動けない！` });
                        attacker.recharge = false; // Reset for next turn
                        return; // Skip action
                    }

                    // Paralysis Check
                    if (act.type === 'move') {
                        // Freeze check
                        if (attacker.status && attacker.status.condition === 'frz') {
                            if (Math.random() < 0.2) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} のこおりがとけた！` });
                                attacker.status = null;
                            } else {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} はこおってしまって動けない！` });
                                return;
                            }
                        }

                        // Sleep check
                        if (attacker.status && attacker.status.condition === 'slp') {
                            attacker.status.turns--;
                            if (attacker.status.turns <= 0) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は目をさました！` });
                                attacker.status = null;
                            } else {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} はぐうぐう眠っている...` });
                                return;
                            }
                        }

                        // Confusion Check
                        if (attacker.confusion) {
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は こんらんしている！` });
                            attacker.confusion.turns--;
                            if (attacker.confusion.turns <= 0) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} の こんらんが とけた！` });
                                attacker.confusion = null;
                            } else {
                                if (Math.random() < 0.33) {
                                    this.turnQueue.push({ type: 'text', msg: 'わけもわからず 自分を攻撃した！' });
                                    // Self Hit Calc (Power 40, Typeless Physical)
                                    let a = attacker.stats.atk * this.getRankMultiplier(attacker.ranks.atk);
                                    let d = attacker.stats.def * this.getRankMultiplier(attacker.ranks.def);
                                    if (attacker.status && attacker.status.condition === 'brn') a = Math.floor(a * 0.5);
                                    let dmg = Math.floor(Math.floor(Math.floor(2 * attacker.lv / 5 + 2) * 40 * a / d) / 50) + 2;

                                    simState[actorIdx].currentHp -= dmg;
                                    if (simState[actorIdx].currentHp < 0) simState[actorIdx].currentHp = 0;
                                    this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: dmg });
                                    return;
                                }
                            }
                        }

                        // Paralysis check
                        if (attacker.status && attacker.status.condition === 'par') {
                            if (Math.random() < 0.25) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は体がしびれて動けない！` });
                                return;
                            }
                        }
                    }

                    if (act.type === 'switch') {
                        const oldMon = actorP.team[simActiveIdx[actorIdx]];
                        const newMon = actorP.team[act.switchIdx];

                        // Clear Substitute, Choice Lock, Transform, and Imprison on switch
                        oldMon.substituteHP = 0;
                        oldMon.choiceMove = null; // Reset choice lock
                        oldMon.isTransformed = false;
                        oldMon.isImprisoning = false;
                        this.checkBoosterEnergy(newMon);

                        this.turnQueue.push({
                            type: 'switch',
                            actorIdx: actorIdx,
                            newActiveIdx: act.switchIdx,
                            oldName: oldMon.name,
                            newName: newMon.name
                        });
                        simActiveIdx[actorIdx] = act.switchIdx;
                        simState[actorIdx].currentHp = newMon.currentHp;

                        // --- Entry Hazards ---
                        const hazards = actorP.hazards;
                        const isFlying = newMon.types.includes('flying');
                        const isBoots = (newMon.item === 'あつぞこブーツ');

                        // 1. Stealth Rock (Affects everyone, damage depends on effectiveness)
                        if (hazards.rocks && !isBoots) {
                            let eff = 1.0;
                            newMon.types.forEach(t => {
                                if (t !== 'none' && TYPE_CHART['rock'] && TYPE_CHART['rock'][t]) {
                                    eff *= TYPE_CHART['rock'][t];
                                }
                            });
                            const rockDmg = Math.floor(newMon.stats.hp * 0.125 * eff);
                            if (rockDmg > 0) {
                                newMon.currentHp -= rockDmg;
                                simState[actorIdx].currentHp = newMon.currentHp;
                                this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: rockDmg, msg: '尖った岩が食い込む！' });
                            }
                        }

                        // 2. Spikes (Grounded only)
                        if (hazards.spikes > 0 && !isFlying && !isBoots) {
                            const mult = [0, 0.125, 0.166, 0.25];
                            const spikesDmg = Math.floor(newMon.stats.hp * mult[hazards.spikes]);
                            if (spikesDmg > 0) {
                                newMon.currentHp -= spikesDmg;
                                simState[actorIdx].currentHp = newMon.currentHp;
                                this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: spikesDmg, msg: 'まきびしが刺さる！' });
                            }
                        }

                        // 3. Toxic Spikes (Grounded only)
                        if (hazards.tspikes > 0 && !isFlying && !newMon.types.includes('steel') && !isBoots) {
                            if (newMon.types.includes('poison')) {
                                hazards.tspikes = 0; // Absorption
                                this.turnQueue.push({ type: 'text', msg: 'どくびしが消えた！' });
                            } else if (!newMon.status) {
                                if (hazards.tspikes === 1) {
                                    newMon.status = { condition: 'psn', turns: 0 };
                                    this.turnQueue.push({ type: 'text', msg: `${newMon.name} は 毒を浴びた！` });
                                } else {
                                    newMon.status = { condition: 'psn', turns: 0 }; // Simplified Toxic
                                    this.turnQueue.push({ type: 'text', msg: `${newMon.name} は 猛毒を浴びた！` });
                                }
                            }
                            this.turnQueue.push({ type: 'text', msg: `${newMon.name} は 猛毒を浴びた！` });
                        }
                    } else if (act.type === 'move') {
                        let move = attacker.moves[act.moveIdx];

                        // --- Outrage Lock Check (Turn Start) ---
                        if (attacker.outrage) {
                            move = moveDB['げきりん'] || moveDB['Outrage'] || { name: 'げきりん', type: 'dragon', category: 'physical', power: 120, accuracy: 100, effect: { meta: { outrage: true } } };
                            // Force target to random if needed, but resolveTurn handles random target logic?
                            // For simplicity, we keep the original targetIdx unless we want to re-roll random.
                            // Outrage targets random opponent in doubles, but here single battle is standard.
                        }

                        // --- Burn Up (もえつきる) Check ---
                        if (move.name === 'もえつきる' && !attacker.types.includes('fire')) {
                            this.turnQueue.push({ type: 'text', msg: 'しかし うまくきまらなかった！' });
                            return;
                        }

                        // --- Metronome (ゆびをふる) ---
                        if (move.name === 'ゆびをふる' || move.name === 'Metronome') {
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 指を振った！` });
                            const banned = ['ゆびをふる', 'まねっこ', 'バトンタッチ', 'へんしん', 'ふういん', 'まもる', 'みきり', 'みがわり'];
                            const keys = Object.keys(moveDB).filter(k => !banned.includes(k) && k !== '-');
                            const rndKey = keys[Math.floor(Math.random() * keys.length)];
                            move = moveDB[rndKey];
                            this.turnQueue.push({ type: 'text', msg: `${move.name} が 出た！` });
                        }

                        // --- Copycat (まねっこ) ---
                        if (move.name === 'まねっこ' || move.name === 'Copycat') {
                            if (this.lastMoveUsed) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は ${this.lastMoveUsed.name} を まねっこした！` });
                                move = this.lastMoveUsed;
                            } else {
                                this.turnQueue.push({ type: 'text', msg: 'しかし うまくきまらなかった！' });
                                return;
                            }
                        }

                        // --- Dream Eater (ゆめくい) ---
                        if (move.name === 'ゆめくい' || move.name === 'Dream Eater') {
                            if (!defender.status || defender.status.condition !== 'slp') {
                                this.turnQueue.push({ type: 'text', msg: 'しかし うまくきまらなかった！' });
                                return;
                            }
                        }

                        // --- Baton Pass (バトンタッチ) ---
                        if (move.name === 'バトンタッチ' || move.name === 'Baton Pass') {
                            const p = this.players[actorIdx];
                            const bench = p.team.map((m, i) => ({ m, i })).filter(x => x.i !== p.activeIdx && x.m.currentHp > 0);
                            if (bench.length > 0) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 手持ちに戻っていった！` });
                                this.turnQueue.push({ type: 'forceSwitchAction', actorIdx: actorIdx, isBatonPass: true });
                            } else {
                                this.turnQueue.push({ type: 'text', msg: 'しかし 控えがいなかった！' });
                            }
                            return;
                        }

                        // --- Imprison (ふういん) ---
                        if (move.name === 'ふういん' || move.name === 'Imprison') {
                            attacker.isImprisoning = true;
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 周りの技を 封じ込めた！` });
                            return;
                        }

                        // Imprison Check
                        if (defender.isImprisoning) {
                            const knownByEnemy = defender.moves.some(m => m.name === move.name);
                            if (knownByEnemy) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 封印されているため 技が出せない！` });
                                return;
                            }
                        }

                        // --- Assist (ねこのて) ---
                        if (move.name === 'ねこのて' || move.name === 'Assist') {
                            const p = actorP;
                            const teamMoves = p.team.flatMap((mon, idx) =>
                                idx === p.activeIdx ? [] : mon.moves.filter(mv => mv && mv.name && mv.name !== '-')
                            );
                            const banned = ['ねこのて', 'Assist', 'ゆびをふる', 'Metronome', 'まねっこ', 'Copycat', 'へんしん', 'Transform', 'ふういん', 'Imprison', 'まもる', 'みきり', 'みがわり', 'カウンター', 'ミラーコート', 'ほろびのうた', 'バトンタッチ', 'ほえる', 'ふきとばし', 'ドラゴンテール', 'ともえなげ'];
                            const candidates = teamMoves.filter(mv => !banned.includes(mv.name));
                            if (candidates.length > 0) {
                                const chosen = candidates[Math.floor(Math.random() * candidates.length)];
                                move = moveDB[chosen.name] || chosen;
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 仲間の技を 繰り出した！` });
                                this.turnQueue.push({ type: 'text', msg: `${move.name}！` });
                                // Continue with chosen move
                            } else {
                                this.turnQueue.push({ type: 'text', msg: 'しかし 技が出せなかった！' });
                                return;
                            }
                        }

                        // --- Perish Song (ほろびのうた) ---
                        if (move.name === 'ほろびのうた' || move.name === 'Perish Song') {
                            if (!attacker.perish) attacker.perish = 4;
                            if (!defender.perish) defender.perish = 4;
                            this.turnQueue.push({ type: 'text', msg: '滅びの歌が 聞こえてきた！' });
                            return;
                        }

                        // --- Transform (へんしん) ---
                        if (move.name === 'へんしん' || move.name === 'Transform') {
                            if (attacker.isTransformed || defender.isTransformed) {
                                this.turnQueue.push({ type: 'text', msg: 'しかし うまくきまらなかった！' });
                                return;
                            }
                            attacker.isTransformed = true;
                            attacker.types = [...defender.types];
                            attacker.stats = { ...defender.stats, hp: attacker.stats.hp }; // HP stays same
                            attacker.ranks = defender.ranks ? { ...defender.ranks } : { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                            attacker.moves = defender.moves.map(m => ({ ...m, pp: 5, maxPp: 5 }));

                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は ${defender.name} に へんしんした！` });
                            return;
                        }

                        // --- Psych Up (じこあんじ) ---
                        if (move.name === 'じこあんじ' || move.name === 'Psych Up') {
                            if (defender.ranks) {
                                attacker.ranks = JSON.parse(JSON.stringify(defender.ranks));
                            } else {
                                attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                            }
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は ${defender.name} の 能力変化を コピーした！` });
                            return; // Ends turn as it is a status move with only this effect
                        }

                        // Psychic Terrain Block Check (Priority > 0 targeting enemy)
                        const moveData = moveDB[move.name] || move;
                        const pri = getPriority(actorP); // includes Grassy Glide check
                        if (this.terrain === 'psychic' && pri > 0 && simState[targetIdx].currentHp > 0) {
                            // Check if target is grounded (not flying)
                            if (!defender.types.includes('flying')) {
                                this.turnQueue.push({ type: 'text', msg: `サイコフィールドで ${attacker.name} は 攻撃できない！` });
                                return;
                            }
                        }

                        // Sleep Check (Electric/Misty Terrain)
                        if (act.type === 'move') {
                            // Already inside check, merging logic...
                        }

                        // Assault Vest Check
                        if (attacker.item === 'とつげきチョッキ' && move.category === 'status') {
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は とつげきチョッキで 変化技が出せない！` });
                            return;
                        }

                        // Choice Lock Check
                        const choiceItems = ['こだわりハチマキ', 'こだわりメガネ', 'こだわりスカーフ'];
                        if (choiceItems.includes(attacker.item) && attacker.choiceMove && attacker.choiceMove !== move.name) {
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は こだわりアイテムで 技が縛られている！` });
                            return;
                        }
                        if (choiceItems.includes(attacker.item)) {
                            attacker.choiceMove = move.name;
                        }

                        // const moveData = moveDB[move.name] || move; // Already declared above
                        const effect = moveData.effect || {};

                        // --- Charge Execution Logic (Turn 1) ---
                        const isCharged = (attacker.chargingMove === move.name);
                        if (effect.meta && effect.meta.charge && !isCharged) {
                            // Weather Exception
                            let skipCharge = false;
                            const heavySun = ['sun', 'severe_sun'].includes(this.weather);
                            if ((move.name === 'ソーラービーム' || move.name === 'ソーラーブレード') && heavySun) {
                                skipCharge = true;
                            }

                            if (!skipCharge) {
                                attacker.chargingMove = move.name;

                                let msg = `${attacker.name} は 力を溜めている！`;
                                if (move.name === 'ソーラービーム') msg = `${attacker.name} は 光を吸収した！`;
                                if (move.name === 'ソーラーブレード') msg = `${attacker.name} は 光を吸収した！`;
                                if (move.name === 'ゴッドバード') msg = `${attacker.name} は 激しい光に 包まれた！`;
                                if (move.name === 'かまいたち') msg = `${attacker.name} は かまいたちの風を つくりだした！`;
                                if (move.name === 'ロケットずつき') msg = `${attacker.name} は 首を引っ込めた！`;
                                if (move.name === 'フリーズボルト') msg = `${attacker.name} は 凍りつく光に 包まれた！`;
                                if (move.name === 'コールドフレア') msg = `${attacker.name} は 凍てつく空気に 包まれた！`;
                                if (move.name === 'メテオビーム') msg = `${attacker.name} に 宇宙の力が あふれだす！`;
                                if (move.name === 'ジオコントロール') msg = `${attacker.name} は パワーを溜めている！`;

                                if (move.name === 'あなをほる') msg = `${attacker.name} は 地面に潜った！`;
                                if (move.name === 'そらをとぶ') msg = `${attacker.name} は 空高く飛び上がった！`;
                                if (move.name === 'とびはねる') msg = `${attacker.name} は 高く飛び跳ねた！`;
                                if (move.name === 'ダイビング') msg = `${attacker.name} は 水中に身を潜めた！`;
                                if (move.name === 'シャドーダイブ') msg = `${attacker.name} は 姿を消した！`;
                                if (move.name === 'ゴーストダイブ') msg = `${attacker.name} は 姿を隠した！`;

                                this.turnQueue.push({ type: 'text', msg: msg });

                                if (effect.meta.startInvulnerable) {
                                    attacker.invulnerableState = effect.meta.startInvulnerable;
                                }

                                // Turn 1 Stat Effects
                                if (effect.meta.chargeEffect) {
                                    const parts = effect.meta.chargeEffect.split('_'); // e.g. 'def_+1'
                                    const stat = parts[0];
                                    const stage = parseInt(parts[1]);

                                    if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    attacker.ranks[stat] = Math.max(-6, Math.min(6, attacker.ranks[stat] + stage));

                                    const statNames = { atk: '攻撃', def: '防御', spa: '特攻', spd: '特防', spe: '素早さ' };
                                    const stageText = (stage > 0) ? '上がった' : '下がった';
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} の ${statNames[stat]} が ${stageText}！` });
                                }
                                return;
                            }
                        }

                        if (isCharged) {
                            attacker.chargingMove = null;
                            attacker.invulnerableState = null;
                        }

                        // --- Recharge Check ---
                        if (attacker.recharge) {
                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 反動で 動けない！` });
                            attacker.recharge = false;
                            return;
                        }

                        // --- Protection Success Check ---
                        if (effect.meta && effect.meta.protect) {
                            if (!attacker.protectCount) attacker.protectCount = 0;
                            const successRate = Math.pow(1 / 3, attacker.protectCount);
                            if (Math.random() < successRate) {
                                attacker.isProtected = true;
                                attacker.protectCount++;
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は まもりに入った！` });
                                return; // Protection move ends here
                            } else {
                                attacker.protectCount = 0;
                                this.turnQueue.push({ type: 'text', msg: 'しかし うまくきまらなかった！' });
                                return;
                            }
                        } else {
                            // Reset count if non-protect move used
                            attacker.protectCount = 0;
                        }

                        this.turnQueue.push({
                            type: 'text',
                            msg: `${attacker.name} の ${move.name}！`
                        });

                        // --- Protection Block Check ---
                        if (defender.isProtected) {
                            this.turnQueue.push({ type: 'text', msg: `${defender.name} は 守りに守られている！` });
                            // Contact effects
                            if (move.category === 'physical' && defender.isProtected) {
                                const protEff = (moveDB[defender.lastProtectMove] || {}).effect || {}; // Need to track last protect move
                                // Simplified: fetch from moveData of the move used by defender if it was a protect move
                                // But defender might have used it in PREVIOUS action in the same turn.
                                // Let's use metadata stored on the defender.
                                if (defender.currentProtectEffect === 'psn') {
                                    if (!attacker.status) {
                                        attacker.status = { condition: 'psn', turns: 0 };
                                        this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 毒を浴びた！` });
                                    }
                                } else if (defender.currentProtectEffect === 'brn') {
                                    if (!attacker.status) {
                                        attacker.status = { condition: 'brn', turns: 0 };
                                        this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 火傷を負った！` });
                                    }
                                } else if (defender.currentProtectEffect === 'atk_-1') {
                                    if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    attacker.ranks.atk = Math.max(-6, attacker.ranks.atk - 1);
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} の 攻撃が 下がった！` });
                                } else if (defender.currentProtectEffect === 'def_-2') {
                                    if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    attacker.ranks.def = Math.max(-6, attacker.ranks.def - 2);
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} の 防御が がくっと下がった！` });
                                } else if (defender.currentProtectEffect === 'spe_-1') {
                                    if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    attacker.ranks.spe = Math.max(-6, attacker.ranks.spe - 1);
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} の 素早さが 下がった！` });
                                } else if (defender.currentProtectEffect === 'dmg_1/8') {
                                    const rec = Math.floor(attacker.stats.hp / 8);
                                    simState[actorIdx].currentHp -= rec;
                                    this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: rec, effMsg: 'トゲのダメージを受けた！', targetName: attacker.name });
                                }
                            }
                            return;
                        }

                        // --- 命中判定ロジック ---
                        let hit = true;
                        const attackerAccRank = attacker.ranks ? attacker.ranks.acc : 0;
                        const defenderEvaRank = defender.ranks ? defender.ranks.eva : 0;
                        const accMult = this.getAccRankMultiplier(attackerAccRank);
                        const evaMult = this.getAccRankMultiplier(defenderEvaRank);
                        let accBase = CUSTOM_ACCURACY[move.name] !== undefined ? CUSTOM_ACCURACY[move.name] : (moveData.accuracy !== undefined ? moveData.accuracy : 100);
                        if (attacker.item === '広角レンズ') accBase = Math.floor(accBase * 1.1);

                        // Invulnerability Check
                        let invulnerableMiss = false;
                        if (defender.invulnerableState) {
                            invulnerableMiss = true;
                            // Exceptions (Simplified)
                            const s = defender.invulnerableState;
                            const m = move.name;
                            if (s === 'dig' && (m === 'じしん' || m === 'マグニチュード')) invulnerableMiss = false;
                            if (s === 'fly' && (m === 'かみなり' || m === 'ぼうふう' || m === 'うちおとす')) invulnerableMiss = false;
                            if (s === 'bounce' && (m === 'かみなり' || m === 'ぼうふう' || m === 'うちおとす')) invulnerableMiss = false;
                            if (s === 'dive' && (m === 'なみのり' || m === 'うずしお')) invulnerableMiss = false;
                            if (effect.flags && effect.flags.alwaysHit && s !== 'shadow' && s !== 'phantom') invulnerableMiss = false; // Always hit moves (mostly)
                        }

                        if (effect.meta && effect.meta.ohko) {
                            hit = true;
                        } else if (invulnerableMiss) {
                            hit = false;
                        } else if (!(effect.flags && effect.flags.alwaysHit)) {
                            if (Math.random() * 100 > (accBase * accMult / evaMult)) hit = false;
                        }

                        if (!hit) {
                            // Message differentiation
                            if (invulnerableMiss) {
                                this.turnQueue.push({ type: 'text', msg: `${defender.name} は 攻撃を避けた！` });
                            } else {
                                this.turnQueue.push({ type: 'text', msg: '攻撃は外れた！' });
                            }
                        } else {
                            // Hit Success
                            if (effect.meta && effect.meta.weather) {
                                this.turnQueue.push({ type: 'weather', weather: effect.meta.weather });
                            }

                            let hits = 1;
                            if (move.name === 'ネズミざん') {
                                hits = 10; // Try up to 10 times
                            } else if (effect.multihit) {
                                let min = effect.multihit[0];
                                let max = effect.multihit[1];
                                if (attacker.item === 'いかさまダイス' && max >= 4) {
                                    if (min < 4) min = 4;
                                }
                                hits = Math.floor(Math.random() * (max - min + 1)) + min;
                            }

                            let totalDmg = 0;
                            const attackerAccRankChain = attacker.ranks ? attacker.ranks.acc : 0;
                            const defenderEvaRankChain = defender.ranks ? defender.ranks.eva : 0;
                            const accMultChain = this.getAccRankMultiplier(attackerAccRankChain);
                            const evaMultChain = this.getAccRankMultiplier(defenderEvaRankChain);

                            for (let h = 0; h < hits; h++) {
                                if (move.name === 'ネズミざん' && h > 0) {
                                    if (Math.random() * 100 > (accBase * accMultChain / evaMultChain)) break;
                                }

                                let dmg = 0;
                                let effMsg = "";

                                if (move.category === 'status') {
                                    // --- Substitute Execution ---
                                    if (effect.meta && effect.meta.substitute) {
                                        const cost = Math.floor(attacker.stats.hp / 4);
                                        if (attacker.substituteHP > 0) {
                                            this.turnQueue.push({ type: 'text', msg: '既に身代わりが出ている！' });
                                        } else if (simState[actorIdx].currentHp <= cost) {
                                            this.turnQueue.push({ type: 'text', msg: 'HPが足りない！' });
                                        } else {
                                            simState[actorIdx].currentHp -= cost;
                                            attacker.currentHp = simState[actorIdx].currentHp;
                                            attacker.substituteHP = cost + 1;
                                            this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: cost, msg: `${attacker.name} は 身代わりを作った！` });
                                        }
                                    }
                                    // --- Hazard Execution ---
                                    if (effect.meta && effect.meta.hazard) {
                                        const h = effect.meta.hazard;
                                        if (h === 'rocks') {
                                            if (targetP.hazards.rocks) this.turnQueue.push({ type: 'text', msg: '既にステロがまかれている！' });
                                            else { targetP.hazards.rocks = true; this.turnQueue.push({ type: 'text', msg: '相手の周りに岩が浮遊した！' }); }
                                        } else if (h === 'spikes') {
                                            if (targetP.hazards.spikes >= 3) this.turnQueue.push({ type: 'text', msg: 'これ以上まけない！' });
                                            else { targetP.hazards.spikes++; this.turnQueue.push({ type: 'text', msg: '相手の足元にまきびしをまいた！' }); }
                                        } else if (h === 'tspikes') {
                                            if (targetP.hazards.tspikes >= 2) this.turnQueue.push({ type: 'text', msg: 'これ以上まけない！' });
                                            else { targetP.hazards.tspikes++; this.turnQueue.push({ type: 'text', msg: '相手の足元にどくびしをまいた！' }); }
                                        }
                                    }
                                } else if (effect.fixedDamage) {
                                    dmg = effect.fixedDamage;
                                } else if (effect.meta && effect.meta.ohko) {
                                    if (attacker.lv < defender.lv) {
                                        dmg = 0; effMsg = "レベルが 足りない！";
                                    } else {
                                        // User requested: "Always hit checked (done outside), but 30% KO, 70% 0 damage"
                                        // We stick to the standard formula base of 30 + level diff, or just strict 30?
                                        // The user said "30% chance". Let's do standard formula but ensure it works.
                                        // If the user REALLY meant fixed 30%, (attacker.lv - defender.lv) + 30 is roughly 30 for equal levels.
                                        const ohkoAcc = (attacker.lv - defender.lv) + 30;
                                        if (Math.random() * 100 < ohkoAcc) {
                                            dmg = simState[targetIdx].currentHp; effMsg = "一撃必殺！";
                                        } else {
                                            dmg = 0; effMsg = "攻撃は外れた！";
                                        }
                                    }
                                } else {
                                    const res = this.calcDamage(attacker, defender, moveData, effect);
                                    dmg = res.damage;
                                    if (res.superEffective > 1) effMsg = "効果はバツグンだ！";
                                    else if (res.superEffective === 0) effMsg = "効果がないようだ...";
                                    else if (res.superEffective < 1) effMsg = "効果はいまひとつのようだ...";
                                    if (res.superEffective > 0 && dmg === 0) dmg = 1;
                                }

                                // --- Endeavor (がむしゃら) ---
                                if (effect.meta && effect.meta.endeavor) {
                                    const diff = simState[targetIdx].currentHp - simState[actorIdx].currentHp;
                                    if (diff > 0) {
                                        dmg = diff;
                                        effMsg = "がむしゃらに 攻撃した！";
                                        // Skip standard type calc message
                                    } else {
                                        dmg = 0;
                                        effMsg = "攻撃は 失敗した！";
                                    }
                                }

                                // --- Curse (のろい) - Turn Effect Setup ---
                                if (effect.meta && effect.meta.curse) {
                                    if (attacker.types.includes('ghost')) {
                                        // Ghost: Cut 1/2 HP, Curse target
                                        dmg = 0; // No direct damage to target yet
                                        const cost = Math.floor(attacker.stats.hp / 2);
                                        simState[actorIdx].currentHp -= cost;
                                        attacker.currentHp = simState[actorIdx].currentHp; // Sync immediate

                                        if (!defender.status) { // Curse is not a standard status but let's treat it as a volitile or unique prop
                                            defender.cursed = true; // New property
                                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 体力を削って ${defender.name} に のろいをかけた！` });
                                        } else {
                                            defender.cursed = true; // Stack with status? Canonically yes.
                                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 体力を削って ${defender.name} に のろいをかけた！` });
                                        }
                                        effMsg = null; // Handled
                                    } else {
                                        // Non-Ghost: Speed -1, Atk+1, Def+1 (Self)
                                        dmg = 0;
                                        if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };

                                        const chg = (k, v) => {
                                            attacker.ranks[k] += v;
                                            if (attacker.ranks[k] > 6) attacker.ranks[k] = 6;
                                            if (attacker.ranks[k] < -6) attacker.ranks[k] = -6;
                                        };
                                        chg('spe', -1);
                                        chg('atk', 1);
                                        chg('def', 1);

                                        this.turnQueue.push({ type: 'text', msg: `${attacker.name} の 素早さが 下がり 攻撃・防御が 上がった！` });
                                        effMsg = null;
                                    }
                                }

                                // --- Pain Split (いたみわけ) ---
                                if (effect.meta && effect.meta.painSplit) {
                                    const avg = Math.floor((simState[actorIdx].currentHp + simState[targetIdx].currentHp) / 2);
                                    const diffAttacker = avg - simState[actorIdx].currentHp;
                                    const diffDefender = avg - simState[targetIdx].currentHp;

                                    simState[actorIdx].currentHp = avg;
                                    attacker.currentHp = avg;
                                    simState[targetIdx].currentHp = avg;
                                    defender.currentHp = avg;

                                    this.turnQueue.push({ type: 'text', msg: `お互いの体力を 分かち合った！` });
                                    this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: -diffAttacker, msg: '' });
                                    this.turnQueue.push({ type: 'damage', targetIdx: targetIdx, damage: -diffDefender, msg: '' });

                                    dmg = 0; effMsg = null;
                                }

                                // --- Belly Drum (はらだいこ) ---
                                if (effect.meta && effect.meta.bellyDrum) {
                                    if (simState[actorIdx].currentHp <= Math.floor(attacker.stats.hp / 2)) {
                                        this.turnQueue.push({ type: 'text', msg: '体力が足りない！' });
                                    } else {
                                        const cost = Math.floor(attacker.stats.hp / 2);
                                        simState[actorIdx].currentHp -= cost;
                                        attacker.currentHp = simState[actorIdx].currentHp;
                                        if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                        attacker.ranks.atk = 6;
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: cost, msg: `${attacker.name} は 体力を削って パワー全開！` });
                                        this.turnQueue.push({ type: 'text', msg: `${attacker.name} の 攻撃が 最大まで上がった！` });
                                    }
                                    dmg = 0;
                                }

                                // --- Rest (ねむる) ---
                                if (effect.meta && effect.meta.rest) {
                                    if (simState[actorIdx].currentHp === attacker.stats.hp) {
                                        this.turnQueue.push({ type: 'text', msg: '体力が満タンだ！' });
                                    } else {
                                        const healed = attacker.stats.hp - simState[actorIdx].currentHp;
                                        simState[actorIdx].currentHp = attacker.stats.hp;
                                        attacker.currentHp = attacker.stats.hp;
                                        attacker.status = { condition: 'slp', turns: 3 }; // 3 turns (sleeps for 2, wakes up on 3rd action check? commonly status turns decrement at start. set 3 to be safe for 2 turns sleep)
                                        // Valid logic: Turns check at start. If turns>0 decrement. If turns<=0 wake.
                                        // Set 3: Start Turn 1 (Rest).
                                        // Start Turn 2: Check (3->2). Sleep.
                                        // Start Turn 3: Check (2->1). Sleep.
                                        // Start Turn 4: Check (1->0). Wake.
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: -healed, msg: `${attacker.name} は 眠って回復した！` });
                                    }
                                    dmg = 0;
                                }

                                // --- Future Sight (みらいよち) ---
                                if (effect.meta && effect.meta.futureSight) {
                                    if (!this.futureSightQueue) this.futureSightQueue = [];
                                    const res = this.calcDamage(attacker, defender, moveData, effect);
                                    this.futureSightQueue.push({
                                        turns: 3,
                                        damage: res.damage,
                                        targetIdx: targetIdx,
                                        targetName: defender.name
                                    });
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 未来に攻撃を予知した！` });
                                    dmg = 0;
                                }

                                // --- Perish Song (ほろびのうた) ---
                                if (effect.meta && effect.meta.perish) {
                                    [0, 1].forEach(pid => {
                                        const p = this.players[pid];
                                        const mon = p.team[p.activeIdx];
                                        if (!mon.perish) {
                                            mon.perish = 4;
                                            this.turnQueue.push({ type: 'text', msg: `${mon.name} オブ ほろびのカウントが始まった！` }); // Debug msg style? Let's be standard.
                                        }
                                    });
                                    this.turnQueue.push({ type: 'text', msg: 'ほろびのうたが 響き渡る！' });
                                    dmg = 0;
                                }

                                // --- Light Screen / Reflect (ひかりのかべ・リフレクター) ---
                                if (effect.meta && (effect.meta.lightScreen || effect.meta.reflect)) {
                                    if (!attacker.screens) attacker.screens = {};
                                    if (effect.meta.lightScreen) {
                                        attacker.screens.lightScreen = 5;
                                        this.turnQueue.push({ type: 'text', msg: 'ひかりのかべで 攻撃への 守りを固めた！' }); // Correct msg? "味方の 特防が 上がった！" or "ひかりのかべが 現れた！"
                                    }
                                    if (effect.meta.reflect) {
                                        attacker.screens.reflect = 5;
                                        this.turnQueue.push({ type: 'text', msg: 'リフレクターで 物理攻撃への 守りを固めた！' });
                                    }
                                    dmg = 0;
                                }

                                // --- Psych Up (じこあんじ) ---
                                if (effect.meta && effect.meta.psychUp) {
                                    if (!attacker.ranks) attacker.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    if (!defender.ranks) defender.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                    attacker.ranks = { ...defender.ranks };
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 相手の 能力変化を コピーした！` });
                                    dmg = 0;
                                }

                                // --- Outrage Init (げきりん・乱動) ---
                                if (effect.meta && effect.meta.outrage) {
                                    if (!attacker.outrage) {
                                        // Start rampage
                                        attacker.outrage = { turns: Math.floor(Math.random() * 2) + 2 }; // 2-3 turns
                                        // Damage calc continues normally below
                                    }
                                }

                                // --- Apply Confusion ---
                                if (effect.meta && effect.meta.confuse) {
                                    if (!defender.confusion) {
                                        let chance = effect.meta.confuseChance || 30;
                                        if (move.category === 'status') chance = 100;
                                        if (Math.random() * 100 < chance) {
                                            defender.confusion = { turns: Math.floor(Math.random() * 4) + 1 };
                                            this.turnQueue.push({ type: 'text', msg: `${defender.name} は こんらんした！` });
                                        }
                                    }
                                    if (move.category === 'status') dmg = 0;
                                }

                                // --- Substitute Damage Redirection ---
                                if (dmg > 0 && defender.substituteHP > 0) {
                                    const actualDmg = Math.min(dmg, defender.substituteHP);
                                    defender.substituteHP -= actualDmg;
                                    this.turnQueue.push({ type: 'text', msg: `身代わりに ${dmg} のダメージ！` });
                                    if (defender.substituteHP <= 0) {
                                        defender.substituteHP = 0;
                                        this.turnQueue.push({ type: 'text', msg: `${defender.name} の 身代わりは 消滅した！` });
                                    }
                                    dmg = 0; // Prevent main HP damage
                                }

                                // --- Focus Sash Check ---
                                const isFullHp = (simState[targetIdx].currentHp === defender.stats.hp);
                                let potentialDmg = dmg;
                                if (potentialDmg >= simState[targetIdx].currentHp) {
                                    // Make sure we are strictly at max HP before generating the sash effect
                                    if (defender.item === 'きあいのタスキ' && isFullHp && simState[targetIdx].currentHp > 1) {
                                        potentialDmg = simState[targetIdx].currentHp - 1;
                                        defender.consumeItem = true;
                                        this.turnQueue.push({ type: 'text', msg: `${defender.name} は きあいのタスキで 持ちこたえた！` });
                                    } else {
                                        potentialDmg = simState[targetIdx].currentHp;
                                    }
                                }
                                dmg = potentialDmg;

                                simState[targetIdx].currentHp -= dmg;
                                if (simState[targetIdx].currentHp < 0) simState[targetIdx].currentHp = 0;
                                totalDmg += dmg;

                                if (move.category !== 'status') {
                                    this.turnQueue.push({
                                        type: 'damage',
                                        targetIdx: targetIdx,
                                        damage: dmg,
                                        effMsg: (h === 0) ? effMsg : null,
                                        targetName: defender.name
                                    });
                                }

                                // --- Reactive Items (Post-Hit) ---
                                if (simState[targetIdx].currentHp > 0) {
                                    // Weakness Policy
                                    if (defender.item === 'じゃくてんほけん' && effMsg && effMsg.includes('バツグン')) {
                                        defender.consumeItem = true;
                                        if (!defender.ranks) defender.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                        defender.ranks.atk = Math.min(6, defender.ranks.atk + 2);
                                        defender.ranks.spa = Math.min(6, defender.ranks.spa + 2);
                                        this.turnQueue.push({ type: 'text', msg: `じゃくてんほけんで ${defender.name} の 攻撃・特攻が ぐーんと上がった！` });
                                    }

                                    // Eject Button
                                    if (defender.item === 'だっしゅつボタン' && dmg > 0) {
                                        defender.consumeItem = true;
                                        // Force switch logic... complicated in middle of turn. 
                                        // For simplicity, maybe just message "脱出ボタンが発動した！(未実装)" or implement forced switch phase?
                                        // Implementing forced switch requires breaking the loop and changing phase.
                                        // Let's just log it for now or simple "switched out" queue if we can.
                                        this.turnQueue.push({ type: 'text', msg: `${defender.name} は 脱出ボタンで 手持ちに戻った！` });
                                        // Trigger switch... (To be implemented fully, effectively skips rest of turn for this mon)
                                    }

                                    // Healing Berries
                                    const maxHp = defender.stats.hp;
                                    const current = simState[targetIdx].currentHp;
                                    if (defender.item === 'オボンのみ' && current <= maxHp / 2) {
                                        const heal = Math.floor(maxHp / 4);
                                        simState[targetIdx].currentHp = Math.min(maxHp, current + heal);
                                        defender.consumeItem = true;
                                        this.turnQueue.push({ type: 'damage', targetIdx: targetIdx, damage: -heal, msg: `${defender.name} は オボンのみで 回復した！` });
                                    } else if (['イアのみ', 'ウイのみ', 'フィラのみ', 'マゴのみ', 'バンジのみ'].includes(defender.item) && current <= maxHp / 4) {
                                        const heal = Math.floor(maxHp / 3);
                                        simState[targetIdx].currentHp = Math.min(maxHp, current + heal);
                                        defender.consumeItem = true;
                                        this.turnQueue.push({ type: 'damage', targetIdx: targetIdx, damage: -heal, msg: `${defender.name} は 木の実で 回復した！` });
                                    } else if (defender.item === 'オレンのみ' && current <= maxHp / 2) {
                                        const heal = 10;
                                        simState[targetIdx].currentHp = Math.min(maxHp, current + heal);
                                        defender.consumeItem = true;
                                        this.turnQueue.push({ type: 'damage', targetIdx: targetIdx, damage: -heal, msg: `${defender.name} は オレンのみで 回復した！` });
                                    }

                                    // Stat Berries (Liechi, etc.)
                                    if (current <= maxHp / 4) {
                                        const statMap = { 'チイラのみ': 'atk', 'リュガのみ': 'def', 'カムラのみ': 'spe', 'ヤタピのみ': 'spa', 'ズアのみ': 'spd' };
                                        const stat = statMap[defender.item];
                                        if (stat) {
                                            if (!defender.ranks) defender.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                            defender.ranks[stat] = Math.min(6, defender.ranks[stat] + 1);
                                            defender.consumeItem = true;
                                            this.turnQueue.push({ type: 'text', msg: `${defender.name} は 木の実で 能力が上がった！` });
                                        }
                                    }
                                }

                                if (defender.consumeItem) {
                                    defender.item = ''; // Consumed
                                    defender.consumeItem = false;
                                }
                                if (simState[targetIdx].currentHp <= 0) {
                                    hits = h + 1;
                                    break;
                                }
                            }

                            if (hits > 1) {
                                this.turnQueue.push({ type: 'text', msg: `${hits} 回当たった！` });
                            }

                            // --- Added Logic for New Effects ---
                            // 1. Drain (Absorb)
                            if (effect.meta && effect.meta.drain && totalDmg > 0) {
                                const heal = Math.floor(totalDmg * effect.meta.drain);
                                simState[actorIdx].currentHp += heal;
                                if (simState[actorIdx].currentHp > attacker.stats.hp) simState[actorIdx].currentHp = attacker.stats.hp;
                                this.turnQueue.push({
                                    type: 'damage', targetIdx: actorIdx, damage: -heal, // Negative damage = heal visual
                                    msg: `${attacker.name} は 体力を回復した！`
                                });
                            }

                            // 2. Variable Heal
                            if (effect.meta && effect.meta.heal) {
                                let rate = 0;
                                if (effect.meta.heal === 'weather') {
                                    if (this.weather === 'sun' || this.weather === 'severe_sun') rate = 2 / 3; // ~0.66
                                    else if (this.weather === 'rain' || this.weather === 'sandstorm' || this.weather === 'snow' || this.weather === 'hail') rate = 0.25;
                                    else rate = 0.5;
                                } else {
                                    rate = parseFloat(effect.meta.heal) || 0.5;
                                }
                                const heal = Math.floor(attacker.stats.hp * rate);
                                if (heal > 0) {
                                    simState[actorIdx].currentHp += heal;
                                    if (simState[actorIdx].currentHp > attacker.stats.hp) simState[actorIdx].currentHp = attacker.stats.hp;
                                    this.turnQueue.push({
                                        type: 'damage', targetIdx: actorIdx, damage: -heal,
                                        msg: `${attacker.name} は 体力を回復した！`
                                    });
                                } else {
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 体力満タンだ！` });
                                }
                            }

                            // 3. Self Faint (Explosion)
                            if (effect.meta && effect.meta.selfFaint) {
                                simState[actorIdx].currentHp = 0;
                                this.turnQueue.push({
                                    type: 'damage', targetIdx: actorIdx, damage: 9999, // Force 0
                                    msg: `${attacker.name} は 自爆した！`
                                });
                            }

                            // Trapping (Bind/Whirlpool)
                            if (simState[targetIdx].currentHp > 0 && effect.meta && effect.meta.trap) {
                                const turns = Math.floor(Math.random() * 2) + 4; // 4 to 5 turns
                                defender.trapped = { name: effect.meta.trapName, turns: turns, sourceIdx: actorIdx };
                                this.turnQueue.push({ type: 'text', msg: `${defender.name} は ${effect.meta.trapName} に 捕らわれた！` });
                            }

                            // 4. Recharge (Hyper Beam)
                            if (effect.meta && effect.meta.recharge) {
                                attacker.recharge = true;
                            }

                            // 5. Field / Trick Room
                            if (effect.meta && effect.meta.field) {
                                this.terrain = effect.meta.field;
                                this.terrainTurns = 5;
                                const fMap = { electric: 'エレキフィールド', grassy: 'グラスフィールド', misty: 'ミストフィールド', psychic: 'サイコフィールド' };
                                this.turnQueue.push({ type: 'text', msg: `足元が ${fMap[this.terrain]} になった！` });
                            }
                            if (effect.meta && effect.meta.trickroom) {
                                if (this.trickRoomTurns > 0) {
                                    this.trickRoomTurns = 0;
                                    this.turnQueue.push({ type: 'text', msg: '歪んだ寸法が 元に戻った！' });
                                } else {
                                    this.trickRoomTurns = 5;
                                    this.turnQueue.push({ type: 'text', msg: '時空が 歪んでしまった！' });
                                }
                            }

                            // 6. Thief / Trick
                            if (effect.meta && effect.meta.steal && simState[targetIdx].currentHp > 0) {
                                if (!attacker.item && defender.item) {
                                    attacker.item = defender.item;
                                    defender.item = '';
                                    defender.consumeItem = true; // functionally gone from defender
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} は ${defender.name} から ${attacker.item} を 奪った！` });
                                }
                            }
                            if (effect.meta && effect.meta.swapItem && simState[targetIdx].currentHp > 0) {
                                const tmp = attacker.item;
                                attacker.item = defender.item;
                                defender.item = tmp;
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} と ${defender.name} の 持ち物を 交換した！` });
                            }

                            // Original Status/Recoil/Stat logic
                            if (simState[targetIdx].currentHp > 0 || (effect.meta && effect.meta.statSelf)) {
                                if (effect.meta) {
                                    // Status (Covert Cloak check)
                                    if (effect.meta.status && !defender.status && defender.item !== 'おんみつマント') {
                                        const chance = effect.meta.statusChance || 100;
                                        if (Math.random() * 100 < chance) {
                                            const map = { psn: 'どく', par: 'まひ', brn: 'やけど', frz: 'こおり', slp: 'ねむり' };
                                            let turns = 0;
                                            if (effect.meta.status === 'slp') turns = Math.floor(Math.random() * 3) + 1;
                                            let immune = false;
                                            // Immunity logic...
                                            // Immunity logic...
                                            if (effect.meta.status === 'brn' && defender.types.includes('fire')) immune = true;
                                            if ((effect.meta.status === 'psn' || effect.meta.status === 'tox') && (defender.types.includes('poison') || defender.types.includes('steel'))) immune = true;
                                            if (effect.meta.status === 'par' && defender.types.includes('electric')) immune = true;
                                            if (effect.meta.status === 'frz' && defender.types.includes('ice')) immune = true;

                                            // Misty Terrain (Status Prevention for grounded)
                                            if (this.terrain === 'misty' && !defender.types.includes('flying')) immune = true;
                                            // Electric Terrain (Sleep Prevention for grounded)
                                            if (this.terrain === 'electric' && effect.meta.status === 'slp' && !defender.types.includes('flying')) immune = true;

                                            if (!immune) {
                                                const condition = effect.meta.status || 'psn';
                                                let st = { condition: condition, turns: 0 };
                                                if (condition === 'slp') {
                                                    // User Request: Sleep Turns + 1 (Standard 1-3 -> 2-4)
                                                    st.turns = Math.floor(Math.random() * 3) + 2;
                                                }
                                                defender.status = st;

                                                const statusLabelMap = { psn: '毒', tox: '猛毒', par: '麻痺', brn: '火傷', frz: '氷', slp: '眠り' };
                                                this.turnQueue.push({ type: 'text', msg: `${defender.name} は ${statusLabelMap[condition]} になった！` });

                                                // Status Berry Check
                                                const sItem = defender.item;
                                                const sCond = condition;
                                                if (sItem === 'ラムのみ' ||
                                                    (sItem === 'カゴのみ' && sCond === 'slp') ||
                                                    (sItem === 'クラボのみ' && sCond === 'par') ||
                                                    (sItem === 'モモンのみ' && (sCond === 'psn' || sCond === 'tox')) ||
                                                    (sItem === 'チーゴのみ' && sCond === 'brn') ||
                                                    (sItem === 'ナナシのみ' && sCond === 'frz')) {
                                                    defender.status = null;
                                                    defender.item = ''; // Consume immediately
                                                    this.turnQueue.push({ type: 'text', msg: `${defender.name} は ${sItem}で 回復した！` });
                                                }
                                            }
                                        }
                                    }

                                    // --- Reactive Items (Post-Hit Trigger) ---
                                    if (totalDmg > 0 && simState[targetIdx].currentHp > 0) {
                                        // Red Card (レッドカード)
                                        if (defender.item === 'レッドカード' && !defender.consumeItem) {
                                            defender.consumeItem = true;
                                            this.turnQueue.push({ type: 'text', msg: `${defender.name} の レッドカードが 発動した！` });
                                            // Force Attacker Switch (Random)
                                            const p = this.players[actorIdx];
                                            const bench = p.team.map((m, i) => ({ m, i })).filter(x => x.i !== p.activeIdx && x.m.currentHp > 0);
                                            if (bench.length > 0) {
                                                const rnd = bench[Math.floor(Math.random() * bench.length)];
                                                this.turnQueue.push({ type: 'switch', actorIdx: actorIdx, newActiveIdx: rnd.i, oldName: attacker.name, newName: rnd.m.name });
                                                // Actually update state in queue processing or here?
                                                // turnQueue 'switch' type updates activeIdx visually and logically in processNextAction?
                                                // Let's check processNextAction.
                                                // Yes, it sets p.activeIdx.
                                                // BUT, the current loop `order.forEach` might continue using the OLD active mon if we don't be careful.
                                                // `resolveTurn` iterates `order`. If actor was first, and was forced out, the rest of the logic involves `attacker`.
                                                // Since this is "Post-Hit", the turn for this pair is mostly done.
                                                // If actor was second, this is end of turn.
                                                // If actor was first, the second action (by defender) might target the NEW mon?
                                                // `resolveTurn` uses `simActiveIdx` fixed at start. So logic continues targeting old slot?
                                                // This is complex. For now, we queue the switch.
                                            } else {
                                                this.turnQueue.push({ type: 'text', msg: 'しかし 控えがいなかった！' });
                                            }
                                        }

                                        // Eject Button (だっしゅつボタン)
                                        if (defender.item === 'だっしゅつボタン' && !defender.consumeItem) {
                                            defender.consumeItem = true;
                                            this.turnQueue.push({ type: 'text', msg: `${defender.name} の だっしゅつボタンが 発動した！` });
                                            // Force Defender Switch (Request)
                                            // This should ideally prompt user.
                                            // For automation simplicity: Random switch if CPU, or "Must Switch" state for Player.
                                            // We will push a special 'forceSwitch' action?
                                            // Or simplified: Just random switch for now to ensure mechanic works "normally" (stops turn).
                                            const p = this.players[targetIdx];
                                            const bench = p.team.map((m, i) => ({ m, i })).filter(x => x.i !== p.activeIdx && x.m.currentHp > 0);
                                            if (bench.length > 0) {
                                                // TODO: If Player, show UI.
                                                // Simulating random for now to unblock mechanic.
                                                const rnd = bench[Math.floor(Math.random() * bench.length)];
                                                this.turnQueue.push({ type: 'switch', actorIdx: targetIdx, newActiveIdx: rnd.i, oldName: defender.name, newName: rnd.m.name });
                                            }
                                        }
                                    }
                                    // Recoil (Damage based)
                                    if (effect.meta.recoil && totalDmg > 0) {
                                        const rec = Math.floor(totalDmg * effect.meta.recoil);
                                        simState[actorIdx].currentHp -= rec;
                                        if (simState[actorIdx].currentHp < 0) simState[actorIdx].currentHp = 0;
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: rec, effMsg: '反動のダメージを受けた！' });
                                    }

                                    // --- Switching Move Logic ---
                                    if (effect.meta.switchingMove && totalDmg > 0 && simState[targetIdx].currentHp >= 0) {
                                        const p = this.players[actorIdx];
                                        const bench = p.team.map((m, i) => ({ m, i })).filter(x => x.i !== p.activeIdx && x.m.currentHp > 0);
                                        if (bench.length > 0) {
                                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 手持ちに戻っていった！` });
                                            // Handle this similar to Eject Button for now?
                                            // Ideally, switch happens after damage.
                                            // For automation we might need to handle this specially.
                                            this.turnQueue.push({ type: 'forceSwitchAction', actorIdx: actorIdx });
                                        }
                                    }

                                    // --- Post-Move Updates ---
                                    this.lastMoveUsed = move; // For Copycat

                                    // Outrage Loop Decrement
                                    if (attacker.outrage) {
                                        attacker.outrage.turns--;
                                        if (attacker.outrage.turns <= 0) {
                                            attacker.outrage = null;
                                            this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 暴れすぎて こんらんした！` });
                                            // Apply confusion
                                            if (!attacker.confusion) {
                                                attacker.confusion = { turns: Math.floor(Math.random() * 4) + 1 };
                                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は こんらんした！` });
                                            }
                                        }
                                    }

                                    // Recoil (Max HP based - Steel Beam)
                                    if (effect.meta.recoilMaxHp) {
                                        const rec = Math.floor(attacker.stats.hp * effect.meta.recoilMaxHp);
                                        simState[actorIdx].currentHp -= rec;
                                        if (simState[actorIdx].currentHp < 0) simState[actorIdx].currentHp = 0;
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: rec, effMsg: '体力を削って攻撃した！', targetName: attacker.name });
                                    }

                                    // Life Orb Recoil
                                    if (attacker.item === 'いのちのたま' && totalDmg > 0) {
                                        const loRec = Math.floor(attacker.stats.hp / 10);
                                        simState[actorIdx].currentHp -= loRec;
                                        if (simState[actorIdx].currentHp < 0) simState[actorIdx].currentHp = 0;
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: loRec, effMsg: '命が 削られた！', targetName: attacker.name });
                                    }
                                }

                                if (effect.statChanges) {
                                    effect.statChanges.forEach(ch => {
                                        // Clear Amulet Check
                                        if (ch.target !== 'self' && ch.stage < 0 && defender.item === 'クリアチャーム') {
                                            this.turnQueue.push({ type: 'text', msg: `${defender.name} の クリアチャームが 能力ダウンを防いだ！` });
                                            return;
                                        }

                                        const targetObj = (ch.target === 'self') ? attacker : defender;
                                        const targetPName = (ch.target === 'self') ? attacker.name : defender.name;
                                        if (!targetObj.ranks) targetObj.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0, acc: 0 };
                                        targetObj.ranks[ch.stat] += ch.stage;
                                        if (targetObj.ranks[ch.stat] > 6) targetObj.ranks[ch.stat] = 6;
                                        if (targetObj.ranks[ch.stat] < -6) targetObj.ranks[ch.stat] = -6;
                                        const statNames = { atk: '攻撃', def: '防御', spa: '特攻', spd: '特防', spe: '素早さ', eva: '回避率', acc: '命中率' };
                                        const stageText = (ch.stage >= 2) ? 'ぐーんと上がった' : (ch.stage === 1) ? '上がった' : (ch.stage <= -2) ? 'がくっと下がった' : '下がった';
                                        this.turnQueue.push({ type: 'text', msg: `${targetPName} の ${statNames[ch.stat]} が ${stageText}！` });
                                    });
                                }

                                // --- Burn Up Type Removal ---
                                if (effect.meta && effect.meta.burnUp && totalDmg > 0) {
                                    attacker.types = attacker.types.filter(t => t !== 'fire');
                                    if (attacker.types.length === 0) attacker.types = ['none'];
                                    this.turnQueue.push({ type: 'text', msg: `${attacker.name} は 燃え尽きて ほのおタイプが なくなった！` });
                                }
                            }

                            if (simState[targetIdx].currentHp <= 0) {
                                this.turnQueue.push({ type: 'text', msg: `${defender.name} は倒れた！` });
                                this.turnQueue.push({ type: 'faint', targetIdx: targetIdx });
                            }
                            if (simState[actorIdx].currentHp <= 0 && effect.meta && effect.meta.selfFaint) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は倒れた！` });
                                this.turnQueue.push({ type: 'faint', targetIdx: actorIdx });
                            }
                        }
                    }
                });

                this.processNextAction();
            },

            processNextAction: function () {
                if (this.turnQueue.length === 0) {
                    // End of turn processing
                    this.endTurn();
                    return;
                }

                const action = this.turnQueue.shift();
                const logBox = document.getElementById('battle-log');

                const wait = (ms) => setTimeout(() => this.processNextAction(), ms);

                if (action.type === 'text') {
                    logBox.innerText += action.msg + "\n";
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(800);
                }
                else if (action.type === 'damage') {
                    const targetP = this.players[action.targetIdx];
                    const active = targetP.team[targetP.activeIdx];
                    active.currentHp -= action.damage;
                    if (active.currentHp < 0) active.currentHp = 0;
                    if (active.currentHp > active.stats.hp) active.currentHp = active.stats.hp;

                    // Update UI
                    this.updateHpDisplay();

                    const logMsg = action.effMsg || action.msg;
                    if (logMsg) {
                        logBox.innerText += logMsg + "\n";
                    }
                    logBox.innerText += `(HP: ${active.currentHp}/${active.stats.hp})\n`;
                    logBox.scrollTop = logBox.scrollHeight;

                    wait(1000);
                }
                else if (action.type === 'switch') {
                    const p = this.players[action.actorIdx];
                    const oldMon = p.team[p.activeIdx];
                    const newMon = p.team[action.newActiveIdx];

                    logBox.innerText += `${p.name} は ${action.oldName} を戻して ${action.newName} を繰り出した！\n`;

                    // Baton Pass Transfer
                    if (this.batonPassPending) {
                        newMon.ranks = { ...oldMon.ranks };
                        newMon.confusion = oldMon.confusion ? { ...oldMon.confusion } : null;
                        newMon.substituteHP = oldMon.substituteHP || 0;
                        this.batonPassPending = false;
                        logBox.innerText += `能力変化と状態が 引き継がれた！\n`;
                    }

                    p.activeIdx = action.newActiveIdx;
                    this.updateHpDisplay();
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(1500);
                }
                else if (action.type === 'faint') {
                    logBox.innerText += `${action.targetName || 'ポケモン'} は倒れた！\n`;
                    logBox.scrollTop = logBox.scrollHeight;
                    this.updateHpDisplay();
                    wait(1200);
                }
                else if (action.type === 'weather') {
                    this.weather = action.weather;
                    this.weatherTurns = 5; // Default 5 turns
                    const map = { sun: 'ひざしがつよい', rain: 'あめがふりだした', sandstorm: 'すなあらしがふきあれた', snow: 'ゆきがふりだした' };
                    logBox.innerText += `${map[action.weather]}！\n`;
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(1000);
                }
                else if (action.type === 'forceSwitchAction') {
                    // Triggered by switching moves (Volt Switch, etc.) or Eject Button
                    this.currentPlayerIndex = action.actorIdx;
                    if (action.isBatonPass) this.batonPassPending = true;
                    this.showSwitchScreen(true);
                    // processNextAction stops here because showSwitchScreen takes over
                }
            },

            endTurn: function () {
                const logBox = document.getElementById('battle-log');
                const p1 = this.players[0];
                const p2 = this.players[1];
                const hasAlive = (p) => p.team.some(m => m.currentHp > 0);

                // End of turn damage/effects queue
                let endQueue = [];

                if (this.endOfTurnStage === 0) {
                    // Field / Trick Room Management
                    if (this.trickRoomTurns > 0) {
                        this.trickRoomTurns--;
                        if (this.trickRoomTurns <= 0) endQueue.push({ type: 'text', msg: '歪んだ寸法が 元に戻った！' });
                    }
                    if (this.terrain !== 'none') {
                        this.terrainTurns--;
                        if (this.terrainTurns <= 0) {
                            endQueue.push({ type: 'text', msg: 'フィールドが 元に戻った！' });
                            this.terrain = 'none';
                        } else {
                            // Grassy Terrain Heal
                            if (this.terrain === 'grassy') {
                                [p1, p2].forEach((p, idx) => {
                                    const mon = p.team[p.activeIdx];
                                    if (mon.currentHp > 0 && mon.currentHp < mon.stats.hp && !mon.types.includes('flying')) {
                                        const rec = Math.floor(mon.stats.hp / 16) || 1;
                                        mon.currentHp = Math.min(mon.stats.hp, mon.currentHp + rec);
                                        endQueue.push({ type: 'damage', targetIdx: idx, damage: -rec, msg: `${mon.name} は グラスフィールドで 回復した！` });
                                    }
                                });
                            }
                        }
                    }
                    this.endOfTurnStage = 1;
                    // Weather
                    if (this.weather !== 'none') {
                        this.weatherTurns--;
                        if (this.weatherTurns <= 0) {
                            endQueue.push({ type: 'text', msg: 'てんきがもとにもどった。' });
                            this.weather = 'none';
                        } else {
                            // Sandstorm damage
                            [p1, p2].forEach((p, idx) => {
                                const mon = p.team[p.activeIdx];
                                if (this.weather === 'sandstorm' && mon.currentHp > 0) {
                                    if (!mon.types.includes('rock') && !mon.types.includes('ground') && !mon.types.includes('steel')) {
                                        const dmg = Math.floor(mon.stats.hp / 16) || 1;
                                        endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'すなあらしのダメージをうけている！' });
                                    }
                                }
                            });
                        }
                    }

                    // Status Damage
                    // Status Damage
                    [p1, p2].forEach((p, idx) => {
                        const mon = p.team[p.activeIdx];
                        if (mon.currentHp > 0 && mon.status) {
                            if (mon.status.condition === 'brn') {
                                const dmg = Math.floor(mon.stats.hp / 16) || 1;
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'やけどのダメージをうけている！' });
                            } else if (mon.status.condition === 'psn') {
                                const dmg = Math.floor(mon.stats.hp / 8) || 1;
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'どくのダメージをうけている！' });
                            } else if (mon.status.condition === 'tox') {
                                mon.status.turns++;
                                const dmg = Math.floor(mon.stats.hp * mon.status.turns / 16) || 1;
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: '毒が回っている！' });
                            }
                        }

                        // Curse Damage
                        if (mon.currentHp > 0 && mon.cursed) {
                            const dmg = Math.floor(mon.stats.hp / 4) || 1;
                            endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: `${mon.name} は のろわれている！` });
                        }

                        // Trapping Damage
                        if (mon.currentHp > 0 && mon.trapped) {
                            const tName = mon.trapped.name;
                            const dmg = Math.floor(mon.stats.hp / 8) || 1;
                            endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: `${mon.name} は ${tName} による ダメージを受けている！` });
                            mon.trapped.turns--;
                            if (mon.trapped.turns <= 0) {
                                endQueue.push({ type: 'text', msg: `${mon.name} の ${tName} が 解けた！` });
                                mon.trapped = null;
                            }
                        }
                    });

                    // Perish Song (ほろびのうた)
                    [p1, p2].forEach((p, idx) => {
                        const mon = p.team[p.activeIdx];
                        if (mon.currentHp > 0 && mon.perish) {
                            mon.perish--;
                            if (mon.perish === 0) {
                                endQueue.push({ type: 'text', msg: `${mon.name} の ほろびのカウントが 0 になった！` });
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: mon.currentHp, msg: `${mon.name} は 滅びた！` });
                            } else {
                                endQueue.push({ type: 'text', msg: `${mon.name} の ほろびのカウントが ${mon.perish} になった！` });
                            }
                        }
                    });

                    // Future Sight (みらいよち)
                    if (this.futureSightQueue) {
                        for (let i = this.futureSightQueue.length - 1; i >= 0; i--) {
                            const fs = this.futureSightQueue[i];
                            fs.turns--;
                            if (fs.turns === 0) {
                                const targetP = this.players[fs.targetIdx];
                                const active = targetP.team[targetP.activeIdx];
                                if (active.currentHp > 0) {
                                    endQueue.push({
                                        type: 'damage',
                                        targetIdx: fs.targetIdx,
                                        damage: fs.damage,
                                        msg: `${active.name} に 未来の攻撃が当たった！`
                                    });
                                } else {
                                    endQueue.push({ type: 'text', msg: '未来の攻撃は 失敗した！' });
                                }
                                this.futureSightQueue.splice(i, 1);
                            }
                        }
                    }

                    // Item Effects (Leftovers)
                    [p1, p2].forEach((p, idx) => {
                        const mon = p.team[p.activeIdx];
                        if (mon.currentHp > 0 && mon.currentHp < mon.stats.hp) {
                            if (mon.item === 'たべのこし') {
                                const rec = Math.floor(mon.stats.hp / 16) || 1;
                                mon.currentHp = Math.min(mon.stats.hp, mon.currentHp + rec);
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: -rec, msg: `${mon.name} は たべのこしで 回復した！` });
                            }
                            if (mon.item === 'くろいへどろ') {
                                if (mon.types.includes('poison')) {
                                    const rec = Math.floor(mon.stats.hp / 16) || 1;
                                    mon.currentHp = Math.min(mon.stats.hp, mon.currentHp + rec);
                                    endQueue.push({ type: 'damage', targetIdx: idx, damage: -rec, msg: `${mon.name} は くろいへどろで 回復した！` });
                                } else {
                                    const dmg = Math.floor(mon.stats.hp / 8) || 1;
                                    endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: `${mon.name} は くろいへどろで ダメージを受けた！` });
                                }
                            }
                        }
                    });

                    if (endQueue.length > 0) {
                        // Temporary merge to turnQueue to process them
                        this.turnQueue = endQueue;
                        this.processNextAction();
                        return;
                    }
                }

                this.endOfTurnStage = 2; // Completed
                // Check if anyone dead needs replacement
                const p1Dead = p1.team[p1.activeIdx].currentHp === 0;
                const p2Dead = p2.team[p2.activeIdx].currentHp === 0;

                if (p1Dead) {
                    if (!hasAlive(p1)) {
                        this.showGameOver(1);
                        return;
                    }
                    this.currentPlayerIndex = 0; this.showSwitchScreen(true); return;
                }
                if (p2Dead) {
                    if (!hasAlive(p2)) {
                        this.showGameOver(0);
                        return;
                    }
                    this.currentPlayerIndex = 1; this.showSwitchScreen(true); return;
                }

                // Show Next Turn Button or Auto
                const btn = document.querySelector('#screen-result button');
                if (btn) {
                    btn.disabled = false;
                    btn.onclick = () => {
                        this.resetTurnActions();
                        app.nextTurn();
                    };
                }
            },

            calcDamage: function (attacker, defender, move, effect = null) {
                const lv = attacker.lv;
                let power = move.power;
                let moveType = move.type;

                // --- Weather Ball ---
                if (move.name === 'ウェザーボール' || move.name === 'Weather Ball') {
                    if (this.weather === 'sun' || this.weather === 'severe_sun') { moveType = 'fire'; power = 100; }
                    else if (this.weather === 'rain' || this.weather === 'heavy_rain') { moveType = 'water'; power = 100; }
                    else if (this.weather === 'sandstorm') { moveType = 'rock'; power = 100; }
                    else if (this.weather === 'snow' || this.weather === 'hail') { moveType = 'ice'; power = 100; }
                    else { power = 50; moveType = 'normal'; }
                }

                // --- Stored Power (アシストパワー) ---
                if (move.name === 'アシストパワー' || move.name === 'Stored Power' || (effect && effect.meta && effect.meta.storedPower)) {
                    let boosts = 0;
                    if (attacker.ranks) {
                        const stats = ['atk', 'def', 'spa', 'spd', 'spe', 'eva', 'acc'];
                        stats.forEach(s => {
                            if (attacker.ranks[s] > 0) boosts += attacker.ranks[s];
                        });
                    }
                    power = 20 + (20 * boosts);
                }

                // --- Screens Damage Reduction (Reflect / Light Screen) ---
                let screenMod = 1.0;
                if (defender.screens) {
                    if (move.category === 'physical' && defender.screens.reflect > 0) {
                        screenMod = 0.5;
                        // In critical hits, screens are ignored? Typically yes, unless current gen changed.
                        // We will apply it at final modifier stage or base damage?
                        // Screens usually apply to raw damage or base power?
                        // Actually it's a damage modifier. We'll apply it later.
                    }
                    if (move.category === 'special' && defender.screens.lightScreen > 0) {
                        screenMod = 0.5;
                    }
                }

                // --- Variable Power Check ---
                if (effect && effect.variablePower) {
                    const vp = effect.variablePower;
                    if (vp.type === 'hp_high') {
                        power = Math.floor(150 * attacker.currentHp / attacker.stats.hp);
                        if (power < 1) power = 1;
                    } else if (vp.type === 'hp_low') {
                        const p = 48 * attacker.currentHp / attacker.stats.hp;
                        if (p < 2) power = 200;
                        else if (p < 5) power = 150;
                        else if (p < 10) power = 100;
                        else if (p < 21) power = 80;
                        else if (p < 35) power = 40;
                        else power = 20;
                    } else if (vp.type === 'speed_slow') {
                        const userSpe = Math.max(1, this.getActualSpeed(attacker));
                        const targetSpe = Math.max(1, this.getActualSpeed(defender));
                        power = Math.floor((targetSpe / userSpe) * 25) + 1;
                        if (power > 150) power = 150;
                    } else if (vp.type === 'speed_fast') {
                        const userSpe = Math.max(1, this.getActualSpeed(attacker));
                        const targetSpe = Math.max(1, this.getActualSpeed(defender));
                        const r = userSpe / targetSpe;
                        if (r >= 4) power = 150;
                        else if (r >= 3) power = 120;
                        else if (r >= 2) power = 80;
                        else if (r >= 1) power = 60;
                        else power = 40;
                    }
                }

                if (power <= 0) return { damage: 0, superEffective: 1 };

                // 1. Determine Stats (A and D)
                const isPhys = move.category === 'physical';
                let a = isPhys ? attacker.stats.atk : attacker.stats.spa;
                let d = isPhys ? defender.stats.def : defender.stats.spd;

                // 1a. Rank Modifiers
                const atkRank = isPhys ? attacker.ranks.atk : attacker.ranks.spa;
                const defRank = isPhys ? defender.ranks.def : defender.ranks.spd;

                // Critical Hit ignores negative Attack stages and positive Defense stages
                const critRate = (effect && effect.meta && effect.meta.critRate) ? 2 : 0;
                let critStage = (critRate >= 2) ? 2 : 0;
                if (attacker.item === 'ピントレンズ') critStage += 1;

                let critChance = 0.04;
                if (critStage === 1) critChance = 0.125;
                else if (critStage === 2) critChance = 0.5;
                else if (critStage >= 3) critChance = 1.0;

                const isCrit = Math.random() < critChance;

                let effectiveAtkRank = atkRank;
                let effectiveDefRank = defRank;

                if (isCrit) {
                    if (effectiveAtkRank < 0) effectiveAtkRank = 0;
                    if (effectiveDefRank > 0) effectiveDefRank = 0;
                }

                a = Math.floor(a * this.getRankMultiplier(effectiveAtkRank));
                d = Math.floor(d * this.getRankMultiplier(effectiveDefRank));

                // 1b. Weather Stat Boosts (Sand/Snow) - Stat Level
                if (this.weather === 'sandstorm' && defender.types.includes('rock') && !isPhys) {
                    d = Math.floor(d * 1.5); // Rock gets SpD boost in Sand
                }
                if (this.weather === 'snow' && defender.types.includes('ice') && isPhys) {
                    d = Math.floor(d * 1.5); // Ice gets Def boost in Snow (Gen 9)
                }

                // 1c. Protosynthesis / Quark Drive (Booster Energy) - Stat Level
                if (attacker.item === 'ブーストエナジー' && attacker.boosterStat) {
                    const cat = isPhys ? 'atk' : 'spa';
                    if (attacker.boosterStat === cat) a = Math.floor(a * 1.3);
                }
                if (defender.item === 'ブーストエナジー' && defender.boosterStat) {
                    const cat = isPhys ? 'def' : 'spd';
                    if (defender.boosterStat === cat) d = Math.floor(d * 1.3);
                }

                // 1d. Choice Items / Assault Vest - Stat Level
                if (isPhys && attacker.item === 'こだわりハチマキ') a = Math.floor(a * 1.5);
                if (!isPhys && attacker.item === 'こだわりメガネ') a = Math.floor(a * 1.5);
                if (!isPhys && defender.item === 'とつげきチョッキ') d = Math.floor(d * 1.5);

                // 2. Base Damage Calculation
                // Formula: floor(floor(floor(2 * L / 5 + 2) * Power * A / D) / 50) + 2
                let baseDmg = Math.floor(Math.floor(Math.floor(2 * lv / 5 + 2) * power * a / d) / 50) + 2;

                // 3. Modifiers (Chain)

                // 3a. Weather (Damage Level) - Sun/Rain
                if (this.weather === 'sun') {
                    if (moveType === 'fire') baseDmg = Math.floor(baseDmg * 1.5);
                    if (moveType === 'water') baseDmg = Math.floor(baseDmg * 0.5);
                } else if (this.weather === 'rain') {
                    if (moveType === 'water') baseDmg = Math.floor(baseDmg * 1.5);
                    if (moveType === 'fire') baseDmg = Math.floor(baseDmg * 0.5);
                }

                // 3b. Critical Hit
                if (isCrit) {
                    baseDmg = Math.floor(baseDmg * 1.5);
                }

                // 3c. Random (0.85 to 1.00)
                // Gen 3+ Formula: floor(Initial * (random(85,100) / 100))
                const rnd = Math.floor(Math.random() * 16) + 85;
                baseDmg = Math.floor(baseDmg * rnd / 100);

                // 3d. STAB
                if (attacker.types.includes(moveType)) {
                    baseDmg = Math.floor(baseDmg * 1.5); // Adaptability would be 2.0
                }

                // 3e. Type Effectiveness
                let typeEff = 1.0;
                defender.types.forEach(defT => {
                    if (defT !== 'none' && TYPE_CHART[moveType] && TYPE_CHART[moveType][defT] !== undefined) {
                        typeEff *= TYPE_CHART[moveType][defT];
                    }
                });
                baseDmg = Math.floor(baseDmg * typeEff);

                // 3e-2. Freeze-Dry (Water Exception)
                if (move.name === 'フリーズドライ' || move.name === 'Freeze-Dry') {
                    // Check if target has water type
                    if (defender.types.includes('water')) {
                        // Logic: If it was resisting ice (0.5) because of water, it should be 2.0.
                        // Standard calc: Ice vs Water = 0.5.
                        // Freeze-Dry vs Water = 2.0.
                        // So we need to multiply by 4?
                        // It's cleaner to re-calculate type eff or adjust simply.
                        // Let's just do a manual patch.
                        // If typeEff includes the 0.5 from Water, cancel it and apply 2.0.
                        // But defender might have other types (e.g. Water/Flying).
                        // Ice vs Water/Flying = 0.5 * 2 = 1.0. 
                        // Freeze-Dry vs Water/Flying = 2.0 * 2 = 4.0.
                        // So yes, we multiply by 4 if Water is present.
                        // Wait, Water resists Ice? Yes. 
                        // So normally Ice vs Water is 0.5. We want it to be 2.0.
                        // 0.5 * 4 = 2.0. Correct.

                        // What if target is Water/Ice?
                        // Ice vs Water/Ice = 0.5 * 0.5 = 0.25.
                        // Freeze-Dry vs Water/Ice = 2.0 * 0.5 = 1.0.
                        // 0.25 * 4 = 1.0. Correct.

                        baseDmg = Math.floor(baseDmg * 4);
                        // Also update superEffective flag for message
                        typeEff *= 4;
                    }
                }

                // 3f. Burn
                if (attacker.status && attacker.status.condition === 'brn' && isPhys && move.name !== 'からげんき') {
                    baseDmg = Math.floor(baseDmg * 0.5);
                }

                // 3g. Items / Terrain / Other
                // Life Orb
                if (attacker.item === 'いのちのたま') baseDmg = Math.floor(baseDmg * 1.3);
                // Punching Glove
                if (attacker.item === 'パンチグローブ' && (move.name.includes('パンチ') || move.name.includes('拳'))) {
                    baseDmg = Math.floor(baseDmg * 1.1);
                }

                // Terrain Damage Modifiers
                const isUserGrounded = !attacker.types.includes('flying') && attacker.item !== 'ふうせん'; // Simple check
                const isTargetGrounded = !defender.types.includes('flying') && defender.item !== 'ふうせん';

                if (this.terrain === 'electric' && move.type === 'electric' && isUserGrounded) baseDmg = Math.floor(baseDmg * 1.3); // Gen 9 is approx 1.3
                if (this.terrain === 'grassy' && move.type === 'grass' && isUserGrounded) baseDmg = Math.floor(baseDmg * 1.3);
                if (this.terrain === 'psychic' && move.type === 'psychic' && isUserGrounded) baseDmg = Math.floor(baseDmg * 1.3);
                if (this.terrain === 'misty' && move.type === 'dragon' && isTargetGrounded) baseDmg = Math.floor(baseDmg * 0.5);

                if (this.terrain === 'grassy' && ['じしん', 'じならし', 'マグニチュード'].includes(move.name)) {
                    baseDmg = Math.floor(baseDmg * 0.5);
                }

                // Type-Resist Berries
                if (typeEff > 1) {
                    const berryMap = {
                        'オッカのみ': 'fire', 'イトケのみ': 'water', 'ソクノのみ': 'electric', 'リリバのみ': 'grass',
                        'ヤチェのみ': 'ice', 'ヨプのみ': 'fighting', 'ビアーのみ': 'poison', 'シュカのみ': 'ground',
                        'バコウのみ': 'flying', 'ウタンのみ': 'psychic', 'タンガのみ': 'bug', 'ハバンのみ': 'dragon',
                        'カシブのみ': 'ghost', 'ロゼルのみ': 'fairy', 'ナモのみ': 'dark', 'リリバのみ': 'steel'
                    };
                    if (berryMap[defender.item] === move.type) {
                        baseDmg = Math.floor(baseDmg * 0.5);
                        defender.consumeItem = true;
                    }
                }

                // Final Protection Check (not full impl, but basic)
                if (baseDmg < 1 && typeEff > 0) baseDmg = 1; // Minimum damage 1 unless immune

                return { damage: baseDmg, superEffective: typeEff, itemConsumed: defender.consumeItem, isCrit: isCrit };
            },

            calcStatsFromData: function (base, ivs, evs, lv, natureKey) {
                const natureData = NATURE_TABLE[natureKey] || NATURE_TABLE["1.0"];
                const calc = (stat, isHp) => {
                    const b = base[stat];
                    const i = ivs[stat];
                    const e = evs[stat];
                    let core = Math.floor((2 * b + i + Math.floor(e / 4)) * lv / 100);
                    if (isHp) return core + lv + 10;
                    else {
                        let res = core + 5;
                        if (natureData.up === stat) res = Math.floor(res * 1.1);
                        if (natureData.down === stat) res = Math.floor(res * 0.9);
                        return res;
                    }
                };
                return {
                    hp: calc('h', true), atk: calc('a', false), def: calc('b', false),
                    spa: calc('c', false), spd: calc('d', false), spe: calc('s', false)
                };
            },

            calcStats: function (prefix) {
                const getVal = (id) => {
                    const el = document.getElementById(id);
                    return el ? (parseInt(el.value) || 0) : 0;
                };
                const lv = getVal(`${prefix}_lv`);
                const natureKeyEl = document.getElementById(`${prefix}_nature`);
                const natureKey = natureKeyEl ? natureKeyEl.value : "1.0";

                const base = {
                    h: getVal(`${prefix}_base_h`), a: getVal(`${prefix}_base_a`), b: getVal(`${prefix}_base_b`),
                    c: getVal(`${prefix}_base_c`), d: getVal(`${prefix}_base_d`), s: getVal(`${prefix}_base_s`)
                };
                const ivs = {
                    h: getVal(`${prefix}_iv_h`), a: getVal(`${prefix}_iv_a`), b: getVal(`${prefix}_iv_b`),
                    c: getVal(`${prefix}_iv_c`), d: getVal(`${prefix}_iv_d`), s: getVal(`${prefix}_iv_s`)
                };
                const evs = {
                    h: getVal(`${prefix}_ev_h`), a: getVal(`${prefix}_ev_a`), b: getVal(`${prefix}_ev_b`),
                    c: getVal(`${prefix}_ev_c`), d: getVal(`${prefix}_ev_d`), s: getVal(`${prefix}_ev_s`)
                };

                return this.calcStatsFromData(base, ivs, evs, lv, natureKey);
            },

            getRankMultiplier: function (stage) {
                if (stage >= 0) return (2 + stage) / 2;
                else return 2 / (2 + Math.abs(stage));
            },

            getAccRankMultiplier: function (rank) {
                const map = {
                    '-6': 0.33, '-5': 0.37, '-4': 0.43, '-3': 0.50, '-2': 0.60, '-1': 0.75,
                    '0': 1.0,
                    '1': 1.33, '2': 1.66, '3': 2.0, '4': 2.33, '5': 2.66, '6': 3.0
                };
                return map[rank] || 1.0;
            },

            checkBoosterEnergy: function (mon) {
                if (mon.item !== 'ブーストエナジー' && mon.item !== 'booster_energy') {
                    mon.boosterStat = null;
                    return;
                }
                if (mon.boosterStat) return; // Already active

                const s = mon.stats;
                let bestStat = 'atk';
                let bestVal = s.atk;

                if (s.def > bestVal) { bestStat = 'def'; bestVal = s.def; }
                if (s.spa > bestVal) { bestStat = 'spa'; bestVal = s.spa; }
                if (s.spd > bestVal) { bestStat = 'spd'; bestVal = s.spd; }
                if (s.spe > bestVal) { bestStat = 'spe'; bestVal = s.spe; }

                mon.boosterStat = bestStat;
            },

            getActualSpeed: function (p) {
                // Simplified speed calculation (Rank + Scarf + Paralysis)
                const rank = p.ranks ? p.ranks.spe : 0;
                let s = p.stats.spe * this.getRankMultiplier(rank);
                if (p.item === 'choice_scarf' || p.item === 'こだわりスカーフ') s *= 1.5;
                if (p.item === 'ブーストエナジー' && p.boosterStat === 'spe') s *= 1.5; // Placeholder for Booster Energy Speed
                if (p.status && p.status.condition === 'par') s *= 0.5;
                if (p.unburden) s *= 2; // Unburden placeholder
                return Math.floor(s);
            },

            updateHpDisplay: function () {
                [0, 1].forEach(i => {
                    const p = this.players[i];
                    if (!p) return;
                    const active = p.team[p.activeIdx];
                    const nameEl = document.getElementById(`res-p${i + 1}-name`);
                    const lvEl = document.getElementById(`res-p${i + 1}-lv`);
                    const bar = document.getElementById(`res-hp-bar-p${i + 1}`);
                    const txt = document.getElementById(`res-hp-text-p${i + 1}`);

                    if (nameEl) {
                        const statusMap = { brn: ' [火傷]', par: ' [麻痺]', psn: ' [毒]', slp: ' [眠り]', frz: ' [氷]' };
                        const statusText = active.status ? statusMap[active.status.condition] : "";
                        const subText = active.substituteHP > 0 ? " [身]" : "";
                        nameEl.innerText = active.name + statusText + subText;
                        nameEl.style.opacity = active.currentHp === 0 ? '0.4' : '1';
                    }
                    if (lvEl) lvEl.innerText = active.lv;

                    const pct = (active.currentHp / active.stats.hp) * 100;
                    if (bar) {
                        bar.style.width = pct + '%';
                        this.setHpColor(bar, pct);
                    }
                    if (txt) {
                        txt.innerText = `${active.currentHp}/${active.stats.hp}`;
                        txt.style.opacity = active.currentHp === 0 ? '0.4' : '1';
                    }
                });

                // --- Input Screen sync ---
                const p = this.players[this.currentPlayerIndex];
                if (p && document.getElementById('screen-input').classList.contains('active')) {
                    const active = p.team[p.activeIdx];
                    const bar = document.getElementById('input-hp-bar');
                    const txt = document.getElementById('input-hp-text');
                    const pct = (active.currentHp / active.stats.hp) * 100;
                    if (bar) {
                        bar.style.width = pct + '%';
                        this.setHpColor(bar, pct);
                    }
                    if (txt) txt.innerText = `${active.currentHp}/${active.stats.hp}`;
                }

                // Weather Display (Update a generic element or log)
                const logBox = document.getElementById('battle-log');
                if (logBox && this.weather !== 'none') {
                    // We could add a persistent weather indicator in future turns
                }
            },

            setHpColor: function (el, pct) {
                if (!el) return;
                el.classList.remove('hp-low', 'hp-crit');
                if (pct < 20) el.classList.add('hp-crit');
                else if (pct < 50) el.classList.add('hp-low');
            },

            performForcedSwitch: function (newIdx) {
                const p = this.players[this.currentPlayerIndex];
                const oldName = p.team[p.activeIdx].name;
                p.activeIdx = newIdx;
                const newName = p.team[p.activeIdx].name;

                // Check if we need to resume a "Death Check" loop or start next turn
                // Logic: If this was a forced switch at end of turn...
                // We should check if the OTHER player also needs to switch
                // Or if we are done, proceed to nextTurn (which starts turn cycle for P1)

                const p1Dead = this.players[0].team[this.players[0].activeIdx].currentHp === 0;
                const p2Dead = this.players[1].team[this.players[1].activeIdx].currentHp === 0;

                if (p1Dead) {
                    this.currentPlayerIndex = 0;
                    this.showSwitchScreen(true);
                    return;
                }
                if (p2Dead) {
                    this.currentPlayerIndex = 1;
                    this.showSwitchScreen(true);
                    return;
                }
                // If everyone alive, start fresh turn
                this.nextTurn();
            },

            showSwitchScreen: function (isForced) {
                if (this.isSinglePlayer && this.currentPlayerIndex === 1) {
                    this.decideCpuSwitch(isForced);
                    return;
                }

                const p = this.players[this.currentPlayerIndex];
                const activeMon = p.team[p.activeIdx];

                // Trapping Check (Voluntary Switch Only)
                if (!isForced && activeMon.trapped) {
                    // Ghost types can escape
                    if (!activeMon.types.includes('ghost')) {
                        alert(`${activeMon.name} は ${activeMon.trapped.name} に 捕まっていて 交代できない！`);
                        return;
                    }
                }

                this.showScreen('screen-switch');
                const switchMsgEl = document.getElementById('switch-msg');
                if (switchMsgEl) switchMsgEl.innerText = isForced ? "強制交代: 戦闘不能です。次を選んでください" : "交代するポケモンを選択";

                const btnCancel = document.getElementById('btn-cancel-switch');
                if (btnCancel) btnCancel.style.display = isForced ? 'none' : 'block';

                const container = document.getElementById('switch-container');
                if (!container) return;
                container.innerHTML = '';

                p.team.forEach((mon, idx) => {
                    if (idx === p.activeIdx) return;
                    const card = document.createElement('div');
                    card.className = 'switch-card';

                    if (mon.currentHp === 0) card.classList.add('disabled');

                    // Base Info
                    const infoDiv = document.createElement('div');
                    infoDiv.style.flex = "1";
                    infoDiv.innerHTML = `<strong>${idx + 1}: ${mon.name}</strong> <span style="font-size:12px">Lv.${mon.lv}</span><br>HP: ${mon.currentHp}/${mon.stats.hp}`;

                    // Status Icon
                    if (mon.status) {
                        const sMap = { brn: '火', par: '麻', psn: '毒', slp: '眠', frz: '氷' };
                        infoDiv.innerHTML += ` <span style="background:#ff5252; color:white; padding:1px 4px; border-radius:3px; font-size:10px;">${sMap[mon.status.condition] || mon.status.condition}</span>`;
                    }

                    card.appendChild(infoDiv);

                    // Move List (Enhanced)
                    const moveDiv = document.createElement('div');
                    moveDiv.className = 'switch-move-list';
                    // moveDiv.style.marginLeft = "10px"; // Optional spacing

                    mon.moves.forEach(m => {
                        if (m.name && m.name !== '-') {
                            const mItem = document.createElement('div');
                            mItem.className = 'switch-move-item';
                            mItem.innerText = m.name;
                            moveDiv.appendChild(mItem);
                        }
                    });

                    // Create a wrapper for layout if needed, or just append
                    // To keep layout clean, maybe put moves on a new line or right side?
                    // Let's put them below the name for clarity as requested "交代先の技などが見れるように"

                    const wrapper = document.createElement('div');
                    wrapper.style.display = 'flex';
                    wrapper.style.flexDirection = 'column';
                    wrapper.style.width = '100%';

                    wrapper.appendChild(infoDiv);
                    wrapper.appendChild(moveDiv);

                    card.innerHTML = ''; // Clear previous simple append
                    card.appendChild(wrapper);


                    card.onclick = () => {
                        if (mon.currentHp === 0) return;

                        if (isForced) {
                            this.performForcedSwitch(idx);
                        } else {
                            this.registerMove(-1, idx);
                        }
                    };
                    container.appendChild(card);
                });
            },

            cancelSwitch: function () {
                this.showScreen('screen-input');
            },

            showScreen: function (id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const el = document.getElementById(id);
                if (el) el.classList.add('active');
            },

            nextTurn: function () {
                if (!this.isSinglePlayer) {
                    this.showScreen('screen-curtain');
                    const pNameEl = document.getElementById('curtain-msg');
                    if (pNameEl) pNameEl.innerText = "ターン終了 - 次へ";
                }
                this.startTurnCycle();
            },

            // --- Game Over & Restart ---
            showGameOver: function (winnerIdx) {
                this.winner = this.players[winnerIdx];
                this.showScreen('screen-gameover');
                const title = document.getElementById('gameover-winner');
                if (title) title.innerText = `Winner: ${this.winner.name}`;
            },

            restartRandom: function () {
                // Generate new random teams for both players
                if (this.isSinglePlayer) {
                    // P1 Random
                    const p1Data = this.generateRandomTeamData(0);
                    this.applyRandomTeamToUi(0);
                    this.players[0].team = this.convertDataToTeam(p1Data);

                    // CPU Random
                    const p2Data = this.generateRandomTeamData(1);
                    this.players[1].team = this.convertDataToTeam(p2Data);
                } else {
                    // PvP
                    [0, 1].forEach(i => {
                        const d = this.generateRandomTeamData(i);
                        this.applyRandomTeamToUi(i);
                        this.players[i].team = this.convertDataToTeam(d);
                    });
                }
                this.initializeBattle();
            },

            restartSame: function () {
                // To reset same team, we need to restore HP and remove status
                // But since 'team' objects are mutated during battle, we need to reset them carefully
                // Simplest way is to recalculate stats from base/ev/iv/lv which we don't strictly keep in the 'team' object
                // except inside 'stats' which is fine, but currentHp is modified.

                // Let's iterate and just reset current HP to stats.hp.
                // However, item consumption etc is also an issue.
                // Ideally, we should re-read from UI inputs or keep a "clean copy".
                // Since this is "Local Sim", let's re-read from UI if possible, OR just hard reset what we can.
                // app.savePlayerData() reads from UI. So calling that might work if UI wasn't destroyed.
                // The setup UI is hidden but elements exist.

                if (this.isSinglePlayer) {
                    // P1 from UI
                    this.savePlayerData(0);

                    // CPU needs regeneration or reset. 
                    // If we want "Same Composition", we need the CPU's original data.
                    // We didn't store CPU clean data. 
                    // Let's just regenerate CPU to be fair (or maybe user wants to retry against same CPU?)
                    // "Same Config" usually implies same matchup.
                    // BUT for now, let's just regenerate CPU if we can't easily restore.
                    // Actually, let's try to reset the existing CPU team objects.
                    this.players[1].team.forEach(m => {
                        m.currentHp = m.stats.hp;
                        m.status = null;
                        m.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                        // Item restoration is tricky if we don't know original item.
                        // We check consumption flag? We didn't track "original item".
                        // Let's assume for CPU we just full heal. Item consumed is lost unless we track it.
                        // Let's add 'originalItem' tracking in future, but for now just heal HP.
                    });
                } else {
                    // PvP - both from UI
                    this.savePlayerData(0);
                    this.savePlayerData(1);
                }
                this.initializeBattle();
            },

            restartManual: function () {
                location.reload();
            },

            // Helper to convert random data to full team structure without UI dependency
            convertDataToTeam: function (dataList) {
                return dataList.map(d => {
                    const poke = pokemonDB[d.name];
                    const base = poke ? { h: poke.hp, a: poke.atk, b: poke.def, c: poke.spa, d: poke.spd, s: poke.spe } : { h: 100, a: 100, b: 100, c: 100, d: 100, s: 100 };
                    const stats = this.calcStatsFromData(base, d.ivs, d.evs, 50, d.nature);

                    const moves = d.moves.map(mName => {
                        const m = moveDB[mName];
                        return m ? { name: mName, type: m.type, category: m.category, power: m.power } : { name: '-', type: 'normal', category: 'physical', power: 0 };
                    });

                    return {
                        name: d.name,
                        lv: 50,
                        stats: stats,
                        currentHp: stats.hp,
                        ranks: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 },
                        moves: moves,
                        types: poke ? [poke.t1, poke.t2] : ['normal', 'none'],
                        status: null,
                        item: d.item,
                        consumeItem: false,
                        substituteHP: 0,
                        chargingMove: null,
                        invulnerableState: null,
                        trapped: null,
                        recharge: false,
                        protectCount: 0,
                        isProtected: false
                    };
                });
            }
        };

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                app.init();

                // Item Datalist Injection
                const items = [
                    'いのちのたま', 'こだわりハチマキ', 'こだわりメガネ', 'こだわりスカーフ', 'パンチグローブ',
                    'とつげきチョッキ', 'おんみつマント', 'クリアチャーム', 'あつぞこブーツ',
                    'きあいのタスキ', 'じゃくてんほけん', 'だっしゅつボタン', 'いかさまダイス', 'ブーストエナジー',
                    'ものまねハーブ', 'くろいへどろ', 'しんかのきせき', 'ゴツゴツメット',
                    '広角レンズ', 'ピントレンズ', 'するどいツメ', 'おうじゃのしるし',
                    'メタルパウダー', 'でんきだま', 'あかいいと',
                    'たべのこし', 'オボンのみ', 'イアのみ', 'ウイのみ', 'フィラのみ', 'マゴのみ', 'バンジのみ', 'オレンのみ',
                    'カゴのみ', 'クラボのみ', 'モモンのみ', 'チーゴのみ', 'ナナシのみ', 'キーのみ', 'ラムのみ',
                    'ヨプのみ', 'シュカのみ', 'バコウのみ', 'ウタンのみ', 'タンガのみ', 'リリバのみ', 'カシブのみ',
                    'ハバンのみ', 'ナモのみ', 'ソクノのみ', 'オッカのみ', 'イトケのみ', 'ロゼルのみ', 'ヤチェのみ', 'ビアーのみ',
                    'チイラのみ', 'リュガのみ', 'カムラのみ', 'ヤタピのみ', 'ズアのみ', 'ナゾのみ'
                ];
                const dl = document.createElement('datalist');
                dl.id = 'item-list';
                items.forEach(i => {
                    const op = document.createElement('option');
                    op.value = i;
                    dl.appendChild(op);
                });
                document.body.appendChild(dl);

                // Attach list attribute to item inputs if not already present
                setTimeout(() => {
                    for (let p = 0; p < 2; p++) {
                        for (let m = 0; m < 6; m++) {
                            const input = document.getElementById(`p${p}_m${m}_item`);
                            if (input) input.setAttribute('list', 'item-list');
                        }
                    }
                }, 1000);

            } catch (e) {
                console.error('app.init error:', e);
            }
        });
    </script>
</body>

</html>
