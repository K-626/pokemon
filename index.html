<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Local Pokemon Battle Sim (Gen 9)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            display: flex;
            justify-content: center;
            padding: 20px;
            margin: 0;
        }

        .container {
            width: 900px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            max-height: 95vh;
            overflow-y: auto;
        }

        h1,
        h2,
        h3,
        h4 {
            text-align: center;
            color: #333;
            margin: 10px 0;
        }

        /* 画面切り替え */
        .screen {
            display: none;
        }

        .active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* タブ UI */
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
            border-bottom: 2px solid #dddddd;
        }

        .tab-btn {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            color: #666;
            border-bottom: 3px solid transparent;
        }

        .tab-btn:hover {
            background: #f9f9f9;
        }

        .tab-btn.active-tab {
            color: #ff5252;
            border-bottom: 3px solid #ff5252;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active-content {
            display: block;
        }

        /* 入力フォーム */
        .wrapper-setup {
            display: flex;
            gap: 20px;
        }

        .player-setup-col {
            flex: 1;
            background: #fafafa;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .input-group {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            background: white;
        }

        .stat-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
            align-items: center;
        }

        .stat-row label {
            width: 40px;
            font-size: 12px;
            font-weight: bold;
        }

        .stat-row input,
        .stat-row select {
            font-size: 12px;
            padding: 3px;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        /* ボタン */
        .btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: #ff5252;
            color: white;
            border: none;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #ff1744;
        }

        .btn-blue {
            background: #2196F3;
        }

        .btn-blue:hover {
            background: #1976D2;
        }

        .btn-move-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .btn-move {
            background: #2196F3;
            padding: 20px;
            font-size: 14px;
        }

        .btn-move:hover {
            background: #1976D2;
        }

        .btn-switch {
            background: #FF9800;
            margin-top: 10px;
        }

        .btn-switch:hover {
            background: #F57C00;
        }

        /* バトル画面 */
        .battle-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 15px;
            background: #eee;
            border-radius: 8px;
        }

        .hp-bar-container {
            width: 200px;
            background: #e0e0e0;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #ccc;
            margin: 5px 0;
        }

        .hp-bar {
            height: 100%;
            background: #4CAF50;
            width: 100%;
            transition: width 0.5s ease-out, background-color 0.3s;
        }

        .hp-low {
            background: #ff9800 !important;
        }

        .hp-crit {
            background: #f44336 !important;
        }

        .log-box {
            background: #263238;
            color: #eceff1;
            padding: 15px;
            height: 200px;
            overflow-y: scroll;
            font-family: 'Consolas', monospace;
            white-space: pre-wrap;
            border-radius: 8px;
            border: 1px solid #455a64;
            margin-bottom: 10px;
        }

        .curtain {
            text-align: center;
            padding: 50px 0;
        }

        .switch-card {
            border: 2px solid #eee;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .switch-card:hover {
            border-color: #2196F3;
        }

        .switch-card.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #ddd;
        }

        .file-upload-box {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            border-radius: 8px;
            background: #fafafa;
        }
    </style>
</head>

<body>

    <datalist id="pokemon-list"></datalist>

    <div class="container">
        <!-- Start Screen -->
        <div id="screen-start" class="screen active">
            <h1>ポケモン対戦シミュレーター (Gen 9)</h1>
            <p style="text-align:center">3vs3 ローカル対戦 / CSV読み込み対応</p>

            <!-- 追加: CSVアップロード UI とステータス -->
            <div class="file-upload-box" id="upload-area">
                <div style="display:flex; justify-content:center; gap:20px;">
                    <div>
                        <p>1. ポケモンデータCSV (名前/HP/種族値...)</p>
                        <input type="file" id="csv-input-poke" accept=".csv"
                            onchange="app.handleCsvUpload(this, 'pokemon')">
                        <p id="csv-status-poke" style="font-size:12px; color:#666;">未ロード</p>
                    </div>
                    <div>
                        <p>2. 技データCSV (名前/タイプ/効果...)</p>
                        <input type="file" id="csv-input-move" accept=".csv"
                            onchange="app.handleCsvUpload(this, 'move')">
                        <p id="csv-status-move" style="font-size:12px; color:#666;">未ロード</p>
                    </div>
                </div>
            </div>
            <p style="text-align:center; color:#666; font-size:14px; margin-bottom:20px;">
                * データ未ロードの場合は手動入力になります<br>
                <button class="btn btn-blue" style="margin-top:10px; width:auto; padding:5px 15px; font-size:12px;"
                    onclick="app.fetchDataFromUrl()">GitHubから最新データを読み込む</button>
            </p>

            <button class="btn" onclick="app.startSetup(0)">Player 1 セットアップ開始</button>
        </div>

        <!-- Setup Screen -->
        <div id="screen-setup" class="screen">
            <h2 id="setup-title">Player X パーティ編成</h2>
            <div id="setup-container"></div> <!-- Dynamic -->
            <button class="btn" id="btn-setup-next" onclick="app.finishSetupStep()">次へ</button>
        </div>

        <!-- Curtain Screen (Setup Intermission & Battle Turns) -->
        <div id="screen-curtain" class="screen">
            <div class="curtain">
                <h2 id="curtain-msg">Player X の番です</h2>
                <p id="curtain-sub">相手に見えないようにPCを操作してください。</p>
                <button class="btn" id="btn-curtain-action" onclick="app.curtainAction()">操作を開始する</button>
            </div>
        </div>

        <!-- Input Screen -->
        <div id="screen-input" class="screen">
            <h2 id="input-player-header">Player X Action</h2>
            <div class="battle-info">
                <div>
                    <strong>現在: <span id="input-active-name"></span></strong>
                    <div class="hp-bar-container">
                        <div id="input-hp-bar" class="hp-bar"></div>
                    </div>
                    <span id="input-hp-text"></span>
                    <div id="input-active-ranks" style="font-size: 14px; margin-top: 5px; color: #444;"></div>
                </div>
                <!-- Weather Indicator -->
                <div id="weather-indicator"
                    style="background:#fff; padding:5px 10px; border-radius:5px; border:1px solid #ccc; font-weight:bold; height:fit-content;">
                    天候: なし</div>
            </div>

            <h3>行動選択</h3>
            <div class="btn-move-container" id="move-buttons"></div>
            <button class="btn btn-switch" onclick="app.showSwitchScreen(false)">ポケモンを交代する</button>
        </div>

        <!-- Switch Screen -->
        <div id="screen-switch" class="screen">
            <h2>交代するポケモンを選択</h2>
            <p id="switch-msg">選択してください</p>
            <div id="switch-container" class="switch-list"></div>
            <button class="btn btn-blue" id="btn-cancel-switch" onclick="app.cancelSwitch()">戻る</button>
        </div>

        <!-- Result Screen -->
        <div id="screen-result" class="screen">
            <h2>ターン結果</h2>
            <div class="battle-info">
                <!-- P1 Status -->
                <div style="text-align: left;">
                    <strong id="res-p1-name">P1</strong> (Lv.<span id="res-p1-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p1" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p1">100/100</span>
                </div>
                <!-- P2 Status -->
                <div style="text-align: right;">
                    <strong id="res-p2-name">P2</strong> (Lv.<span id="res-p2-lv">50</span>)
                    <div class="hp-bar-container">
                        <div id="res-hp-bar-p2" class="hp-bar"></div>
                    </div>
                    <span id="res-hp-text-p2">100/100</span>
                </div>
            </div>

            <div class="log-box" id="battle-log"></div>
            <button class="btn" onclick="app.nextTurn()">次へ</button>
        </div>
    </div>

    <script>
        // ==========================================
        //  CSV設定エリア (ここを変更してください)
        // ==========================================
        const CSV_DATA_EMBEDDED = ``;

        // Raw URL のパスは /<owner>/<repo>/<branch>/<path> の形式にする（refs/heads は不要）
        const CSV_DATA_URL = "https://raw.githubusercontent.com/K-626/pokemon/refs/heads/main/data.csv";

        // 自動読み込みを有効にするには "url" または "embed" に設定します
        // "url" -> CSV_DATA_URL から fetch
        // "embed" -> CSV_DATA_EMBEDDED に埋め込んだテキストを読み込む
        // "manual" -> ファイル入力のみ（今の挙動）
        const USE_CSV_SOURCE = "manual";
        // ==========================================

        // --- Constants & Config ---
        const TYPE_JP_TO_EN = {
            "ノーマル": "normal", "ほのお": "fire", "みず": "water", "くさ": "grass", "でんき": "electric",
            "こおり": "ice", "かくとう": "fighting", "どく": "poison", "じめん": "ground", "ひこう": "flying",
            "エスパー": "psychic", "むし": "bug", "いわ": "rock", "ゴースト": "ghost", "ドラゴン": "dragon",
            "あく": "dark", "はがね": "steel", "フェアリー": "fairy", "": "none"
        };

        const TYPE_CHART = {
            normal: { rock: 0.5, ghost: 0, steel: 0.5 },
            fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
            water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
            electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
            grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
            ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
            fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2, fairy: 0.5 },
            poison: { grass: 2, poison: 0.5, ground: 0.5, rock: 0.5, ghost: 0.5, steel: 0, fairy: 2 },
            ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
            flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
            psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
            bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5, fairy: 0.5 },
            rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
            ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5 },
            dragon: { dragon: 2, steel: 0.5, fairy: 0 },
            dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5 },
            steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5, fairy: 2 },
            fairy: { fire: 0.5, fighting: 2, poison: 0.5, dragon: 2, dark: 2, steel: 0.5 },
            none: {}
        };

        // Custom Accuracy Table (Used when CSV cannot be modified)
        const CUSTOM_ACCURACY = {
            'おうふくビンタ': 85, 'れんぞくパンチ': 85, 'メガトンパンチ': 85,
            'しめつける': 90, 'たたきつける': 75, 'メガトンキック': 75,
            'とびげり': 95, 'まわしげり': 85, 'みだれづき': 85,
            'つのドリル': 30, 'とっしん': 85, 'ミサイルばり': 95,
            'うたう': 55, 'ちょうおんぱ': 55, 'ハイドロポンプ': 80,
            'ふぶき': 70, 'はかいこうせん': 90, 'じごくぐるま': 80,
            'しびれごな': 75, 'ねむりごな': 75, 'どくのこな': 75,
            'かみなり': 70, 'じわれ': 30, 'どくどく': 90,
            'さいみんじゅつ': 60, 'やどりぎのタネ': 90, 'いやなおと': 85,
            'きあいだま': 70, 'ダストシュート': 80, 'ストーンエッジ': 80,
            'じゃれつく': 90, 'ネズミざん': 90, 'かかとおとし': 90,
            'がんせきアックス': 90, 'みずあめボム': 85, 'シャカシャカほう': 90,
            'パワフルエッジ': 95
        };

        const NATURE_TABLE = {
            "1.0": { name: "補正なし", up: null, down: null },
            "adamant": { name: "いじっぱり", up: "atk", down: "spa" },
            "modest": { name: "ひかえめ", up: "spa", down: "atk" },
            "bold": { name: "ずぶとい", up: "def", down: "atk" },
            "timid": { name: "おくびょう", up: "spe", down: "atk" },
            "jolly": { name: "ようき", up: "spe", down: "spa" },
            "impish": { name: "わんぱく", up: "def", down: "spa" },
            "calm": { name: "おだやか", up: "spd", down: "atk" },
            "careful": { name: "しんちょう", up: "spd", down: "spa" },
        };

        const TYPE_EN_TO_JP = {};
        Object.keys(TYPE_JP_TO_EN).forEach(jp => {
            const en = TYPE_JP_TO_EN[jp];
            if (en !== 'none') TYPE_EN_TO_JP[en] = jp;
        });
        TYPE_EN_TO_JP['none'] = 'ー';

        const TEAM_SIZE = 3;
        const MOVES_COUNT = 4;

        // --- CSV Data Store ---
        let pokemonDB = {};
        let moveDB = {};

        // --- App State ---
        const app = {
            players: [],
            setupPlayerIndex: 0,
            turn: 0,
            currentPlayerIndex: 0,
            gameActive: false,
            weather: 'none',
            weatherTurns: 0,
            endOfTurnStage: 0, // 0: not started, 1: damage processed, 2: completed

            // init: safer with element existence checks
            init: function () {
                // Pre-load Logic
                if (USE_CSV_SOURCE === "embed" && CSV_DATA_EMBEDDED.trim() !== "") {
                    this.parseCsv(CSV_DATA_EMBEDDED);
                    const uploadAreaEl = document.getElementById('upload-area');
                    if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "埋め込みデータをロードしました";
                } else if (USE_CSV_SOURCE === "url" && CSV_DATA_URL.trim() !== "") {
                    const csvStatusEl = document.getElementById('csv-status');
                    if (csvStatusEl) csvStatusEl.innerText = "URLからデータを読み込んでいます...";
                    fetch(CSV_DATA_URL)
                        .then(res => {
                            if (!res.ok) throw new Error('HTTP ' + res.status);
                            return res.text();
                        })
                        .then(text => {
                            this.parseCsv(text);
                            const uploadAreaEl = document.getElementById('upload-area');
                            if (uploadAreaEl) uploadAreaEl.style.display = 'none';
                            if (csvStatusEl) csvStatusEl.innerText = "WEBデータをロードしました";
                        })
                        .catch(err => {
                            console.error(err);
                            const csvStatusEl2 = document.getElementById('csv-status');
                            if (csvStatusEl2) csvStatusEl2.innerText = "読み込みエラー (手動アップロードを使用してください)";
                        });
                }
            },

            fetchDataFromUrl: function () {
                const POKE_URL = "https://raw.githubusercontent.com/K-626/pokemon/main/data.csv";
                const MOVE_URL = "https://raw.githubusercontent.com/K-626/pokemon/main/move.csv";

                const fetchOne = (url, type) => {
                    return fetch(url)
                        .then(res => {
                            if (!res.ok) throw new Error('Fetch failed: ' + url);
                            return res.text();
                        })
                        .then(text => {
                            if (type === 'pokemon') this.parseCsv(text);
                            else if (type === 'move') this.parseMoveCsv(text);
                        })
                        .catch(err => {
                            console.error(err);
                            alert("エラー: " + url + " の読み込みに失敗しました。URLが正しいか確認してください。");
                        });
                };

                Promise.all([fetchOne(POKE_URL, 'pokemon'), fetchOne(MOVE_URL, 'move')])
                    .then(() => {
                        const area = document.getElementById('upload-area');
                        if (area) area.style.backgroundColor = '#e8f5e9';
                    });
            },

            // --- CSV Logic ---
            handleCsvUpload: function (input, type) {
                const file = input.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (type === 'pokemon') this.parseCsv(e.target.result);
                    if (type === 'move') this.parseMoveCsv(e.target.result);
                };
                reader.readAsText(file);
            },

            parseMoveCsv: function (text) {
                // Determine headers automatically similar to pokemon csv
                if (!text) return;
                // BOM check
                if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

                const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== "");
                if (lines.length < 2) return;

                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                const find = (keys) => headers.findIndex(h => keys.some(k => h.includes(k)));

                const idxName = find(['名前', 'name']);
                const idxType = find(['タイプ', 'type']);
                const idxCat = find(['分類', 'category', 'cat']);
                const idxPower = find(['威力', 'power']);
                const idxAcc = find(['命中', 'accuracy', 'acc']);
                const idxPriority = find(['優先度', 'priority', 'pri']);
                const idxEffect = find(['効果', 'effect']);

                if (idxName === -1) {
                    alert("技CSVエラー: 名前列が見つかりません");
                    return;
                }

                // Simple parser
                const splitRow = (row) => {
                    const res = []; let cur = ''; let q = false;
                    for (let c of row) {
                        if (c === '"') { q = !q; } else if (c === ',' && !q) { res.push(cur); cur = ''; } else { cur += c; }
                    }
                    res.push(cur); return res;
                };

                let count = 0;
                moveDB = {};
                for (let i = 1; i < lines.length; i++) {
                    const row = splitRow(lines[i]).map(s => s.trim().replace(/^"|"$/g, ''));
                    const name = row[idxName];
                    if (!name) continue;

                    const effStr = (idxEffect !== -1 && row[idxEffect]) ? row[idxEffect] : "";

                    moveDB[name] = {
                        name: name,
                        type: (idxType !== -1) ? (TYPE_JP_TO_EN[row[idxType]] || 'normal') : 'normal',
                        category: (idxCat !== -1 && (row[idxCat] === '変化' || row[idxCat] === 'status' || row[idxCat] === 'へんか')) ? 'status'
                            : (idxCat !== -1 && (row[idxCat] === '特殊' || row[idxCat] === 'special' || row[idxCat] === 'とくしゅ')) ? 'special' : 'physical',
                        power: (idxPower !== -1) ? (parseInt(row[idxPower]) || 0) : 0,
                        accuracy: (idxAcc !== -1) ? (parseInt(row[idxAcc]) || 100) : 100,
                        priority: (idxPriority !== -1) ? (parseInt(row[idxPriority]) || 0) : 0,
                        effect: this.parseMoveEffect(effStr)
                    };
                    count++;
                }
                const st = document.getElementById('csv-status-move');
                if (st) st.innerText = `技データ: ${count}件ロード完了`;
                console.log('MoveDB loaded:', count);

                // Add to datalist if exists
                let dl = document.getElementById('move-list');
                if (!dl) {
                    dl = document.createElement('datalist');
                    dl.id = 'move-list';
                    document.body.appendChild(dl);
                }
                dl.innerHTML = '';
                Object.keys(moveDB).forEach(k => {
                    const op = document.createElement('option');
                    op.value = k;
                    dl.appendChild(op);
                });
            },

            parseMoveEffect: function (str) {
                // Parse the "Effect" column based on user rules
                const res = {
                    meta: {},
                    flags: {}
                };
                if (!str) return res;

                // 2. State Assign
                // "May (poison/paralyze/burn/freeze)"
                if (str.match(/poison/i) || str.includes('どく')) { res.meta.status = 'psn'; res.meta.statusChance = 30; } // Default 30 if not specified
                if (str.match(/paralyze/i) || str.includes('まひ')) { res.meta.status = 'par'; res.meta.statusChance = 30; }
                if (str.match(/burn/i) || str.includes('やけど')) { res.meta.status = 'brn'; res.meta.statusChance = 30; }
                if (str.match(/freeze/i) || str.includes('こおり')) { res.meta.status = 'frz'; res.meta.statusChance = 10; }
                if (str.match(/confuse/i) || str.includes('混乱')) { res.meta.confuse = true; res.meta.confuseChance = 30; }
                if (str.match(/sleep/i) || str.includes('眠り')) { res.meta.status = 'slp'; res.meta.statusChance = 100; }

                // 3. Flinch
                if (str.match(/flinch/i) || str.includes('ひるみ')) { res.meta.flinchChance = 30; }

                // 3. Flinch
                if (str.match(/flinch/i) || str.includes('ひるみ')) { res.meta.flinchChance = 30; }

                // 4. Stats (Enhanced)
                // Format: { target: 'self'|'enemy', stat: 'atk'|'def'|'spa'|'spd'|'spe'|'eva', stage: 1 }
                res.statChanges = [];

                const statMap = {
                    'special attack': 'spa', 'special defense': 'spd',
                    'attack': 'atk', 'defense': 'def', 'sp. atk': 'spa', 'sp. def': 'spd', 'speed': 'spe', 'evasion': 'eva',
                    '攻撃': 'atk', '防御': 'def', '特攻': 'spa', '特防': 'spd', '素早さ': 'spe', '回避率': 'eva'
                };

                const checkStat = (s) => {
                    let target = 'self';
                    let stage = 0;
                    // Self
                    if (s.match(/raises (?:the )?user's/i) || s.includes('自分の')) target = 'self';
                    // Enemy
                    if (s.match(/lowers (?:the )?target's/i) || s.includes('相手の')) target = 'enemy';

                    let statKey = null;
                    // Sort keys by length desc to match "Special Attack" before "Attack"
                    const keys = Object.keys(statMap).sort((a, b) => b.length - a.length);
                    for (const k of keys) {
                        if (s.toLowerCase().includes(k)) {
                            statKey = statMap[k];
                            break;
                        }
                    }
                    if (!statKey) return; // No stat found

                    // Stage
                    if (s.match(/sharply raises/i) || s.match(/by two stages/i) || s.includes('ぐーんと上が') || s.includes('2段階')) stage = 2;
                    else if (s.match(/drastically raises/i) || s.match(/by three stages/i) || s.includes('3段階')) stage = 3;
                    else if (s.match(/raises/i) || s.includes('上がる')) stage = 1;
                    else if (s.match(/harshly lowers/i) || s.match(/by two stages/i) || s.includes('がくっと下が')) stage = -2;
                    else if (s.match(/severely lowers/i) || s.match(/by three stages/i)) stage = -3;
                    else if (s.match(/lowers/i) || s.includes('下がる')) stage = -1;

                    if (stage !== 0) {
                        res.statChanges.push({ target, stat: statKey, stage });
                    }
                };
                checkStat(str);

                if (str.match(/Raises the user's/i) || str.includes('自分の能力を上げ')) {
                    // Fallback or generic logic if specific not caught
                    if (res.statChanges.length === 0) res.meta.statSelf = true;
                }

                // 5. High Crit
                if (str.match(/high critical/i) || str.includes('急所')) { res.meta.critRate = 2; }

                // 6. Never Miss
                if (str.match(/never miss/i) || str.includes('必中')) { res.flags.alwaysHit = true; }

                // 7. Multi Hit
                if (str.match(/Hits 2–5 times/i)) { res.multihit = [2, 5]; }
                if (str.match(/Hits twice/i) || str.includes('2回連続')) { res.multihit = [2, 2]; }

                // 8. Recoil
                if (str.match(/recoil/i) || str.includes('反動')) { res.meta.recoil = 0.25; } // generic 1/4

                // 9. Drain
                if (str.match(/recovers.*damage/i) || str.includes('吸収')) { res.meta.drain = 0.5; }

                // 10. OHKO
                if (str.match(/One-hit KO/i) || str.includes('一撃必殺')) { res.meta.ohko = true; }

                // 11. Weather
                if (str.match(/sunny/i) || str.includes('にほんばれ')) { res.meta.weather = 'sun'; }
                if (str.match(/rain/i) || str.includes('あまごい')) { res.meta.weather = 'rain'; }
                if (str.match(/sandstorm/i) || str.includes('すなあらし')) { res.meta.weather = 'sandstorm'; }
                if (str.match(/snow/i) || str.includes('ゆきげしき')) { res.meta.weather = 'snow'; }

                // 12. Fixed Damage
                const fixed = str.match(/Inflicts (\d+) damage/i);
                if (fixed) { res.fixedDamage = parseInt(fixed[1]); }

                return res;
            },

            parseCsv: function (text) {
                // BOM除去
                if (text && text.charCodeAt && text.charCodeAt(0) === 0xFEFF) {
                    console.log('BOM detected and removed');
                    text = text.slice(1);
                }

                if (!text || typeof text !== 'string') {
                    console.warn('parseCsv: invalid text');
                    return;
                }

                // 改行で分割して空行除去
                const lines = text.split(/\r\n|\n/).filter(l => l.trim() !== "");
                console.log('lines:', lines.length);

                if (lines.length < 2) {
                    console.warn('CSV: 行数不足');
                    const csvStatusEl = document.getElementById('csv-status-poke');
                    if (csvStatusEl) csvStatusEl.innerText = "CSVの行数が不足しています";
                    return;
                }

                // ヘッダー行を取得して表示
                const rawHeaders = lines[0].split(',').map(h => h.trim());
                console.log('raw headers:', rawHeaders);

                // ヘッダー正規化ヘルパー（全角括弧→半角、空白削除、小文字化）
                const normalize = (s) => (s || '').replace(/（/g, '(').replace(/）/g, ')').replace(/\s/g, '').toLowerCase();
                const normHeaders = rawHeaders.map(h => normalize(h));
                console.log('normalized headers:', normHeaders);

                // 緩いマッチでヘッダーのインデックスを探す
                const findHeader = (candidates) => {
                    for (let i = 0; i < normHeaders.length; i++) {
                        for (let c of candidates) {
                            if (normHeaders[i].indexOf(normalize(c)) !== -1) return i;
                        }
                    }
                    return -1;
                };

                const idxName = findHeader(['名前(日本語)', '名前（日本語）', '名前']);
                const idxHP = findHeader(['HP']);
                const idxAtk = findHeader(['攻撃', '攻']);
                const idxDef = findHeader(['防御', '防']);
                const idxSpA = findHeader(['特攻', '特']);
                const idxSpD = findHeader(['特防', '特防御']);
                const idxSpe = findHeader(['素早さ', '素早']);
                const idxT1 = findHeader(['タイプ1', 'タイプ１', 'タイプ']);
                const idxT2 = findHeader(['タイプ2', 'タイプ２']);

                console.log({ idxName, idxHP, idxAtk, idxDef, idxSpA, idxSpD, idxSpe, idxT1, idxT2 });

                if (idxName === -1 || idxHP === -1) {
                    const available = rawHeaders.join(', ');
                    alert("CSVヘッダーエラー: 必須列(名前/HP)が見つかりませんでした。\n検出ヘッダー: " + available);
                    const csvStatusEl = document.getElementById('csv-status-poke');
                    if (csvStatusEl) csvStatusEl.innerText = "ヘッダーエラー: 名前/HP 列が見つかりません";
                    return;
                }

                // 簡易CSVパーサ（"で囲まれたフィールド内のカンマに対応）
                const splitCsvRow = (row) => {
                    const res = [];
                    let cur = '';
                    let inQuotes = false;
                    for (let i = 0; i < row.length; i++) {
                        const ch = row[i];
                        if (ch === '"') {
                            if (inQuotes && row[i + 1] === '"') {
                                cur += '"'; i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (ch === ',' && !inQuotes) {
                            res.push(cur);
                            cur = '';
                        } else {
                            cur += ch;
                        }
                    }
                    res.push(cur);
                    return res;
                };

                let count = 0;
                pokemonDB = {};
                const listEl = document.getElementById('pokemon-list');
                if (listEl) listEl.innerHTML = '';

                for (let i = 1; i < lines.length; i++) {
                    const row = splitCsvRow(lines[i]).map(c => c.trim());
                    // 名前とHPが存在するかを確認（柔軟に扱う）
                    const name = (typeof row[idxName] !== 'undefined') ? row[idxName] : '';
                    const hpVal = (typeof row[idxHP] !== 'undefined') ? row[idxHP] : '';

                    if (!name || !hpVal) {
                        // スキップ前にログ
                        console.debug(`skip row ${i + 1}: name or HP missing`, { name, hpVal, row });
                        continue;
                    }

                    // タイプ列が存在しなければ空文字にする
                    const t1raw = (idxT1 !== -1) ? (row[idxT1] || '') : '';
                    const t2raw = (idxT2 !== -1) ? (row[idxT2] || '') : '';

                    pokemonDB[name] = {
                        hp: parseInt(hpVal) || 0,
                        atk: parseInt(row[idxAtk]) || 0,
                        def: parseInt(row[idxDef]) || 0,
                        spa: parseInt(row[idxSpA]) || 0,
                        spd: parseInt(row[idxSpD]) || 0,
                        spe: parseInt(row[idxSpe]) || 0,
                        t1: TYPE_JP_TO_EN[(t1raw || '').trim()] || "normal",
                        t2: TYPE_JP_TO_EN[(t2raw || '').trim()] || "none"
                    };

                    if (listEl) {
                        const op = document.createElement('option');
                        op.value = name;
                        listEl.appendChild(op);
                    }
                    count++;
                }

                console.log('pokemonDB entries:', count);
                const csvStatusEl = document.getElementById('csv-status-poke');
                if (csvStatusEl) csvStatusEl.innerText = `データ準備完了: ${count} 匹`;
            },

            autoFillStats: function (name, prefix) {
                const data = pokemonDB[name];
                if (data) {
                    const getEl = (id) => document.getElementById(id);
                    if (getEl(`${prefix}_base_h`)) getEl(`${prefix}_base_h`).value = data.hp;
                    if (getEl(`${prefix}_base_a`)) getEl(`${prefix}_base_a`).value = data.atk;
                    if (getEl(`${prefix}_base_b`)) getEl(`${prefix}_base_b`).value = data.def;
                    if (getEl(`${prefix}_base_c`)) getEl(`${prefix}_base_c`).value = data.spa;
                    if (getEl(`${prefix}_base_d`)) getEl(`${prefix}_base_d`).value = data.spd;
                    if (getEl(`${prefix}_base_s`)) getEl(`${prefix}_base_s`).value = data.spe;

                    if (getEl(`${prefix}_type1`)) getEl(`${prefix}_type1`).value = data.t1;
                    if (getEl(`${prefix}_type2`)) getEl(`${prefix}_type2`).value = data.t2;
                }
            },

            // --- Setup Logic ---
            startSetup: function (pIdx) {
                this.setupPlayerIndex = pIdx;
                this.showScreen('screen-setup');
                const setupTitleEl = document.getElementById('setup-title');
                if (setupTitleEl) setupTitleEl.innerText = `Player ${pIdx + 1} パーティ編成`;
                const btn = document.getElementById('btn-setup-next');
                if (btn) btn.innerText = (pIdx === 0) ? "次へ (Player 2へ交代)" : "バトル開始！";
                this.renderSetup(pIdx);
            },

            renderSetup: function (pIdx) {
                const container = document.getElementById('setup-container');
                if (!container) return;
                let html = '<div class="wrapper-setup">';
                html += `<div class="player-setup-col">`;

                html += `<div class="pokemon-tabs-nav">`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    html += `<button class="pokemon-tab ${i === 0 ? 'active' : ''}" onclick="app.switchSetupTab(${i})">Poke ${i + 1}</button>`;
                }
                html += `</div>`;

                for (let i = 0; i < TEAM_SIZE; i++) {
                    let display = i === 0 ? 'block' : 'none';
                    const prefix = `p${pIdx}_m${i}`;

                    html += `<div id="tab-${prefix}" class="tab-content" style="display:${display}">
                        <div class="input-group">
                            <label>ポケモン名 (自動入力対)</label>
                            <input type="text" id="${prefix}_name" list="pokemon-list" placeholder="例: フシギバナ" 
                                onchange="app.autoFillStats(this.value, '${prefix}')" value="">
                            
                            <div class="stat-row" style="margin-top:10px;">
                                <label>Type</label>
                                <select id="${prefix}_type1">${this.renderTypeOptions('normal')}</select>
                                <select id="${prefix}_type2">${this.renderTypeOptions('none', true)}</select>
                            </div>

                            <div class="stat-row">
                                <label>Lv</label><input type="number" id="${prefix}_lv" value="50" style="width:50px">
                                <label>性格</label>
                                <select id="${prefix}_nature">
                                    <option value="1.0">--</option>
                                    <option value="adamant">いじっぱり(A↑ C↓)</option>
                                    <option value="jolly">ようき(S↑ C↓)</option>
                                    <option value="modest">ひかえめ(C↑ A↓)</option>
                                    <option value="timid">おくびょう(S↑ A↓)</option>
                                    <option value="bold">ずぶとい(B↑ A↓)</option>
                                    <option value="impish">わんぱく(B↑ C↓)</option>
                                    <option value="calm">おだやか(D↑ A↓)</option>
                                    <option value="careful">しんちょう(D↑ C↓)</option>
                                </select>
                            </div>
                            <div class="stat-row">
                                <label>持ち物</label>
                                <select id="${prefix}_item">
                                    <option value="">なし</option>
                                    <option value="choice_band">こだわりハチマキ(A1.5倍/技固定)</option>
                                    <option value="choice_specs">こだわりメガネ(C1.5倍/技固定)</option>
                                    <option value="choice_scarf">こだわりスカーフ(S1.5倍/技固定)</option>
                                    <option value="assault_vest">とつげきチョッキ(D1.5倍/変化技不可)</option>
                                </select>
                            </div>
                            <div class="stat-row">
                                <strong>種 / 個 / 努</strong>
                            </div>
                            ${this.renderStatInput(prefix, 'h', 'HP')}
                            ${this.renderStatInput(prefix, 'a', '攻撃')}
                            ${this.renderStatInput(prefix, 'b', '防御')}
                            ${this.renderStatInput(prefix, 'c', '特攻')}
                            ${this.renderStatInput(prefix, 'd', '特防')}
                            ${this.renderStatInput(prefix, 's', '素早')}
                            
                            <hr>
                            <h4>技構成</h4>
                            ${this.renderMovesInput(prefix)}
                        </div>
                    </div>`;
                }
                html += `</div></div>`;
                container.innerHTML = html;
            },

            renderMovesInput: function (prefix) {
                let html = '<div class="move-grid">';
                for (let j = 0; j < MOVES_COUNT; j++) {
                    html += `<div class="input-group" style="margin-bottom:0; padding:5px;">
                        <input type="text" id="${prefix}_move${j}_name" list="move-list" placeholder="技名" onchange="app.autoFillMove(this, '${prefix}_move${j}')">
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <select id="${prefix}_move${j}_type" style="width:60px;">
                                ${this.renderTypeOptions('normal')}
                            </select>
                            <select id="${prefix}_move${j}_cat" style="width:50px;">
                                <option value="physical">物</option>
                                <option value="special">特</option>
                                <option value="status">変</option>
                            </select>
                            <input type="number" id="${prefix}_move${j}_pwr" value="0" placeholder="威" style="width:40px;">
                        </div>
                    </div>`;
                }
                html += '</div>';
                return html;
            },

            autoFillMove: function (input, prefix) {
                const val = input.value;
                if (!moveDB[val]) return;
                const m = moveDB[val];
                const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
                setVal(`${prefix}_type`, m.type);
                setVal(`${prefix}_cat`, m.category);
                setVal(`${prefix}_pwr`, m.power);
            },

            finishSetupStep: function () {
                this.savePlayerData(this.setupPlayerIndex);

                if (this.setupPlayerIndex === 0) {
                    this.showScreen('screen-curtain');
                    const curtainMsgEl = document.getElementById('curtain-msg');
                    if (curtainMsgEl) curtainMsgEl.innerText = "Player 1 セットアップ完了";
                    const curtainSubEl = document.getElementById('curtain-sub');
                    if (curtainSubEl) curtainSubEl.innerText = "Player 2 に交代してください。準備ができたらボタンを押してください。";
                    const btnCurtain = document.getElementById('btn-curtain-action');
                    if (btnCurtain) btnCurtain.onclick = () => {
                        this.startSetup(1);
                    };
                    if (btnCurtain) btnCurtain.innerText = "Player 2 セットアップへ";
                } else {
                    this.initializeBattle();
                }
            },

            savePlayerData: function (pIdx) {
                let team = [];
                for (let m = 0; m < TEAM_SIZE; m++) {
                    const prefix = `p${pIdx}_m${m}`;
                    let stats = this.calcStats(prefix);
                    let moves = [];
                    for (let j = 0; j < 4; j++) {
                        const moveNameEl = document.getElementById(`${prefix}_move${j}_name`);
                        const moveTypeEl = document.getElementById(`${prefix}_move${j}_type`);
                        const moveCatEl = document.getElementById(`${prefix}_move${j}_cat`);
                        const movePwrEl = document.getElementById(`${prefix}_move${j}_pwr`);
                        moves.push({
                            name: moveNameEl ? moveNameEl.value || '-' : '-',
                            type: moveTypeEl ? moveTypeEl.value : 'normal',
                            category: moveCatEl ? moveCatEl.value : 'physical',
                            power: movePwrEl ? parseInt(movePwrEl.value) || 0 : 0
                        });
                    }
                    const nameEl = document.getElementById(`${prefix}_name`);
                    const lvEl = document.getElementById(`${prefix}_lv`);
                    const t1El = document.getElementById(`${prefix}_type1`);
                    const t2El = document.getElementById(`${prefix}_type2`);
                    team.push({
                        name: nameEl ? (nameEl.value || `Poke${m + 1}`) : `Poke${m + 1}`,
                        lv: lvEl ? parseInt(lvEl.value) || 50 : 50,
                        stats: stats,
                        currentHp: stats.hp,
                        ranks: { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0 },
                        moves: moves,
                        types: [
                            t1El ? t1El.value : 'normal',
                            t2El ? t2El.value : 'none'
                        ],
                        status: null, // { condition: 'brn'|'par'|'psn'|'slp'|'frz', turns: N }
                        item: document.getElementById(`${prefix}_item`) ? document.getElementById(`${prefix}_item`).value : ""
                    });
                }
                if (this.players.length <= pIdx) this.players[pIdx] = {};
                this.players[pIdx] = {
                    name: pIdx === 0 ? "Player 1" : "Player 2",
                    team: team,
                    activeIdx: 0,
                    action: null
                };
            },

            renderStatInput: function (prefix, statKey, label) {
                return `<div class="stat-row">
                    <label>${label}</label>
                    <input type="number" id="${prefix}_base_${statKey}" placeholder="種" value="100">
                    <input type="number" id="${prefix}_iv_${statKey}" placeholder="個" value="31">
                    <input type="number" id="${prefix}_ev_${statKey}" placeholder="努" value="${statKey === 'a' || statKey === 's' ? 252 : 0}">
                </div>`;
            },

            renderTypeOptions: function (selected, includeNone = false) {
                let opts = '';
                if (includeNone) opts += `<option value="none" ${selected === 'none' ? 'selected' : ''}>なし</option>`;
                Object.keys(TYPE_CHART).forEach(k => {
                    if (k !== 'none') {
                        const jp = TYPE_EN_TO_JP[k] || k;
                        opts += `<option value="${k}" ${k === selected ? 'selected' : ''}>${jp}</option>`;
                    }
                });
                return opts;
            },

            renderMovesInput: function (prefix) {
                let html = '<div class="move-grid">';
                for (let j = 0; j < MOVES_COUNT; j++) {
                    html += `<div class="input-group" style="margin-bottom:0; padding:5px;">
                        <input type="text" id="${prefix}_move${j}_name" list="move-list" placeholder="技名" onchange="app.autoFillMove(this, '${prefix}_move${j}')">
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <select id="${prefix}_move${j}_type" style="width:60px;">
                                ${this.renderTypeOptions('normal')}
                            </select>
                            <select id="${prefix}_move${j}_cat" style="width:50px;">
                                <option value="physical">物</option>
                                <option value="special">特</option>
                                <option value="status">変</option>
                            </select>
                            <input type="number" id="${prefix}_move${j}_pwr" value="0" placeholder="威" style="width:40px;">
                        </div>
                    </div>`;
                }
                html += '</div>';
                return html;
            },

            autoFillMove: function (input, prefix) {
                const val = input.value;
                if (!moveDB[val]) return;
                const m = moveDB[val];
                const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v; };
                setVal(`${prefix}_type`, m.type);
                setVal(`${prefix}_cat`, m.category);
                setVal(`${prefix}_pwr`, m.power);
                // Can also store accuracy/effect hiddenly if needed, but we look up by name in battle anyway
            },

            switchSetupTab: function (tabIdx) {
                const prefixBase = `p${this.setupPlayerIndex}_m`;
                for (let i = 0; i < TEAM_SIZE; i++) {
                    const el = document.getElementById(`tab-${prefixBase}${i}`);
                    if (el) el.style.display = 'none';
                }
                const showEl = document.getElementById(`tab-${prefixBase}${tabIdx}`);
                if (showEl) showEl.style.display = 'block';
                const bts = document.querySelectorAll('.pokemon-tab');
                bts.forEach(b => b.classList.remove('active'));
                if (bts[tabIdx]) bts[tabIdx].classList.add('active');
            },

            // --- Battle Flow ---

            initializeBattle: function () {
                if (!this.players[0] || !this.players[1]) {
                    alert("エラー: プレイヤーデータが不足しています");
                    return;
                }
                this.turn = 0;
                this.weather = 'none';
                this.weatherTurns = 0;
                this.endOfTurnStage = 0;
                this.updateHpDisplay();
                this.startTurnCycle();
            },

            startTurnCycle: function () {
                this.currentPlayerIndex = 0;
                this.gameActive = true;
                this.checkForcedSwitchStart();
            },

            curtainAction: function () {
                if (this.gameActive) {
                    this.startTurnInput();
                }
            },

            checkForcedSwitchStart: function () {
                const p = this.players[this.currentPlayerIndex];
                if (p.team[p.activeIdx].currentHp === 0) {
                    this.showSwitchScreen(true);
                } else {
                    this.showCurtain();
                }
            },

            showCurtain: function () {
                this.showScreen('screen-curtain');
                const pName = this.players[this.currentPlayerIndex].name;
                const curtainMsgEl = document.getElementById('curtain-msg');
                if (curtainMsgEl) curtainMsgEl.innerText = `${pName} の番です`;
                const curtainSubEl = document.getElementById('curtain-sub');
                if (curtainSubEl) curtainSubEl.innerText = "相手に見えないようにPCを操作してください。";
                const btnCurtain = document.getElementById('btn-curtain-action');
                if (btnCurtain) btnCurtain.onclick = () => app.curtainAction();
                if (btnCurtain) btnCurtain.innerText = "操作を開始する";
            },

            startTurnInput: function () {
                this.showScreen('screen-input');
                const p = this.players[this.currentPlayerIndex];
                const activeMon = p.team[p.activeIdx];

                const headerEl = document.getElementById('input-player-header');
                if (headerEl) headerEl.innerText = `${p.name}: ${activeMon.name} の行動`;
                const nameEl = document.getElementById('input-active-name');
                if (nameEl) {
                    const statusMap = { brn: ' [火傷]', par: ' [麻痺]', psn: ' [毒]', slp: ' [眠り]', frz: ' [氷]' };
                    const statusText = activeMon.status ? statusMap[activeMon.status.condition] : "";
                    nameEl.innerText = activeMon.name + statusText;
                }
                const hpTextEl = document.getElementById('input-hp-text');
                if (hpTextEl) hpTextEl.innerText = `${activeMon.currentHp}/${activeMon.stats.hp}`;

                const pct = (activeMon.currentHp / activeMon.stats.hp) * 100;
                const bar = document.getElementById('input-hp-bar');
                if (bar) {
                    bar.style.width = pct + '%';
                    this.setHpColor(bar, pct);
                }

                const ranksEl = document.getElementById('input-active-ranks');
                if (ranksEl) {
                    const r = activeMon.ranks || { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0 };
                    const labels = { atk: '攻', def: '防', spa: '特攻', spd: '特防', spe: '素', eva: '回' };
                    let txt = [];
                    ['atk', 'def', 'spa', 'spd', 'spe', 'eva'].forEach(k => {
                        const val = r[k];
                        if (val !== 0) {
                            txt.push(`${labels[k]}:${val > 0 ? '+' + val : val}`);
                        }
                    });
                    ranksEl.innerText = txt.length > 0 ? txt.join(" ") : "ランク変化なし";
                }

                // Weather Indicator update
                const weatherEl = document.getElementById('weather-indicator');
                if (weatherEl) {
                    const wMap = { none: 'なし', sun: '晴れ', rain: '雨', sandstorm: '砂あらし', snow: '雪' };
                    weatherEl.innerText = `天候: ${wMap[this.weather]}`;
                    weatherEl.style.backgroundColor = this.weather === 'none' ? '#fff' : '#fff9c4';
                }

                const container = document.getElementById('move-buttons');
                if (container) {
                    container.innerHTML = '';
                    activeMon.moves.forEach((m, idx) => {
                        if (!m.name || m.name === '-') return;
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-move';
                        const typeJp = TYPE_EN_TO_JP[m.type] || m.type;
                        btn.innerHTML = `<strong>${m.name}</strong><br>${typeJp} / ${m.category === 'status' ? '-' : m.power}`;
                        btn.onclick = () => this.registerMove(idx);
                        container.appendChild(btn);
                    });
                }
            },

            registerMove: function (moveIdx, switchIdx = null) {
                const player = this.players[this.currentPlayerIndex];
                if (moveIdx === -1 && switchIdx !== null) {
                    player.action = { type: 'switch', switchIdx: switchIdx };
                } else {
                    player.action = { type: 'move', moveIdx: moveIdx };
                }

                if (this.currentPlayerIndex === 0) {
                    this.currentPlayerIndex = 1;
                    this.checkForcedSwitchStart();
                } else {
                    this.resolveTurn();
                }
            },

            resetTurnActions: function () {
                this.players.forEach(p => p.action = null);
                this.currentPlayerIndex = 0;
            },

            resolveTurn: function () {
                this.showScreen('screen-result');
                const btn = document.querySelector('#screen-result button');
                if (btn) btn.disabled = true;
                const p1 = this.players[0];
                const p2 = this.players[1];

                // ログ初期化
                const logBox = document.getElementById('battle-log');
                logBox.innerText = `--- ターン ${++this.turn} ---\n`;
                this.endOfTurnStage = 0;

                this.turnQueue = [];

                let p1Act = p1.action;
                let p2Act = p2.action;

                // Speed Check
                const getSpeed = (p) => {
                    const mon = p.team[p.activeIdx];
                    let s = mon.stats.spe * this.getRankMultiplier(mon.ranks ? mon.ranks.spe : 0);
                    if (mon.item === 'choice_scarf') s *= 1.5;
                    if (mon.status && mon.status.condition === 'par') s *= 0.5;
                    return Math.floor(s);
                };
                let p1Speed = getSpeed(p1);
                let p2Speed = getSpeed(p2);

                // Priority Logic
                const getPriority = (p) => {
                    const act = p.action;
                    if (act.type === 'switch') return 6;
                    const mon = p.team[p.activeIdx];
                    const move = mon.moves[act.moveIdx];
                    const moveData = moveDB[move.name] || move;
                    return moveData.priority || 0;
                };

                let p1Pri = getPriority(p1);
                let p2Pri = getPriority(p2);

                let order = [];
                if (p1Pri > p2Pri) order = [0, 1];
                else if (p2Pri > p1Pri) order = [1, 0];
                else {
                    // Tie-break by Speed
                    order = (p1Speed >= p2Speed) ? [0, 1] : [1, 0];
                }

                // Simulation State (so we know if someone fainted mid-turn)
                const simState = [
                    { currentHp: p1.team[p1.activeIdx].currentHp },
                    { currentHp: p2.team[p2.activeIdx].currentHp }
                ];
                let simActiveIdx = [p1.activeIdx, p2.activeIdx];

                order.forEach(actorIdx => {
                    const targetIdx = 1 - actorIdx;
                    const actorP = this.players[actorIdx];
                    const targetP = this.players[targetIdx];
                    const act = actorP.action;

                    // Dead check (if killed by first mover)
                    if (simState[actorIdx].currentHp <= 0) return;

                    const attacker = actorP.team[simActiveIdx[actorIdx]];
                    const defender = targetP.team[simActiveIdx[targetIdx]];

                    // Paralysis Check
                    if (act.type === 'move') {
                        // Freeze check
                        if (attacker.status && attacker.status.condition === 'frz') {
                            if (Math.random() < 0.2) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} のこおりがとけた！` });
                                attacker.status = null;
                            } else {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} はこおってしまって動けない！` });
                                return;
                            }
                        }

                        // Sleep check
                        if (attacker.status && attacker.status.condition === 'slp') {
                            attacker.status.turns--;
                            if (attacker.status.turns <= 0) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は目をさました！` });
                                attacker.status = null;
                            } else {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} はぐうぐう眠っている...` });
                                return;
                            }
                        }

                        // Paralysis check
                        if (attacker.status && attacker.status.condition === 'par') {
                            if (Math.random() < 0.25) {
                                this.turnQueue.push({ type: 'text', msg: `${attacker.name} は体がしびれて動けない！` });
                                return;
                            }
                        }
                    }

                    if (act.type === 'switch') {
                        this.turnQueue.push({
                            type: 'switch',
                            actorIdx: actorIdx,
                            newActiveIdx: act.switchIdx,
                            oldName: actorP.team[simActiveIdx[actorIdx]].name,
                            newName: actorP.team[act.switchIdx].name
                        });
                        simActiveIdx[actorIdx] = act.switchIdx;
                        simState[actorIdx].currentHp = actorP.team[act.switchIdx].currentHp;
                    } else if (act.type === 'move') {
                        const move = attacker.moves[act.moveIdx];

                        this.turnQueue.push({
                            type: 'text',
                            msg: `${attacker.name} の ${move.name}！`
                        });

                        const moveData = moveDB[move.name] || move;

                        // 1. Accuracy Check
                        let hit = true;
                        const defenderEvaRank = defender.ranks ? defender.ranks.eva : 0;
                        const evaMult = this.getRankMultiplier(defenderEvaRank);

                        // Use CUSTOM_ACCURACY if available, otherwise moveData.accuracy
                        let accBase = CUSTOM_ACCURACY[move.name] !== undefined ? CUSTOM_ACCURACY[move.name] : (moveData.accuracy !== undefined ? moveData.accuracy : 100);

                        // "Never Miss" flag
                        if (!(moveData.effect && moveData.effect.flags && moveData.effect.flags.alwaysHit)) {
                            // OHKO moves (ats 30% flat in many old gens, 30% here)
                            if (Math.random() * 100 > (accBase / evaMult)) hit = false;
                        }

                        if (!hit) {
                            this.turnQueue.push({ type: 'text', msg: '攻撃は外れた！' });
                        } else {
                            const effect = moveData.effect || {};

                            // ... (rest of the hit logic)

                            // Weather modification moves
                            if (effect.meta && effect.meta.weather) {
                                this.turnQueue.push({ type: 'weather', weather: effect.meta.weather });
                            }

                            let hits = 1;
                            if (effect.multihit) {
                                hits = Math.floor(Math.random() * (effect.multihit[1] - effect.multihit[0] + 1)) + effect.multihit[0];
                            }

                            let totalDmg = 0;
                            for (let h = 0; h < hits; h++) {
                                // For "Nezumi-zan", each hit has its own accuracy check
                                if (move.name === 'ネズミざん' && h > 0) {
                                    if (Math.random() * 100 > accBase) break; // Miss ends the chain
                                }

                                let dmg = 0;
                                let effMsg = "";

                                if (move.category === 'status') {
                                } else if (effect.fixedDamage) {
                                    dmg = effect.fixedDamage;
                                } else if (effect.meta && effect.meta.ohko) {
                                    dmg = simState[targetIdx].currentHp;
                                    effMsg = "一撃必殺！";
                                } else {
                                    const res = this.calcDamage(attacker, defender, moveData, effect);
                                    dmg = res.damage;
                                    if (res.superEffective > 1) effMsg = "効果はバツグンだ！";
                                    else if (res.superEffective === 0) effMsg = "効果がないようだ...";
                                    else if (res.superEffective < 1) effMsg = "効果はいまひとつのようだ...";
                                    if (res.superEffective > 0 && dmg === 0) dmg = 1;
                                }

                                if (dmg > simState[targetIdx].currentHp) dmg = simState[targetIdx].currentHp;
                                simState[targetIdx].currentHp -= dmg;
                                if (simState[targetIdx].currentHp < 0) simState[targetIdx].currentHp = 0;
                                totalDmg += dmg;

                                if (move.category !== 'status') {
                                    this.turnQueue.push({
                                        type: 'damage',
                                        targetIdx: targetIdx,
                                        damage: dmg,
                                        effMsg: (h === 0) ? effMsg : null,
                                        targetName: defender.name
                                    });
                                }
                                if (simState[targetIdx].currentHp <= 0) {
                                    hits = h + 1; // Correct the hit count for log
                                    break;
                                }
                            }

                            if (hits > 1) {
                                this.turnQueue.push({ type: 'text', msg: `${hits} 回当たった！` });
                            }

                            // Effects (Status, Stats, etc.)
                            if (simState[targetIdx].currentHp > 0 || (effect.meta && effect.meta.statSelf)) {
                                if (effect.meta) {
                                    // Status (Application)
                                    if (effect.meta.status && !defender.status) {
                                        const chance = effect.meta.statusChance || 100;
                                        if (Math.random() * 100 < chance) {
                                            const map = { psn: 'どく', par: 'まひ', brn: 'やけど', frz: 'こおり', slp: 'ねむり' };
                                            let turns = 0;
                                            if (effect.meta.status === 'slp') turns = Math.floor(Math.random() * 3) + 1; // 1-3 turns

                                            // Type immunity checks (simplified)
                                            let immune = false;
                                            if (effect.meta.status === 'brn' && defender.types.includes('fire')) immune = true;
                                            if (effect.meta.status === 'psn' && (defender.types.includes('poison') || defender.types.includes('steel'))) immune = true;
                                            if (effect.meta.status === 'par' && defender.types.includes('electric')) immune = true;
                                            if (effect.meta.status === 'frz' && defender.types.includes('ice')) immune = true;

                                            if (!immune) {
                                                defender.status = { condition: effect.meta.status, turns: turns };
                                                this.turnQueue.push({ type: 'text', msg: `${defender.name} は ${map[effect.meta.status]} になった！` });
                                            }
                                        }
                                    }
                                    // Recoil
                                    if (effect.meta.recoil && totalDmg > 0) {
                                        const rec = Math.floor(totalDmg * effect.meta.recoil);
                                        simState[actorIdx].currentHp -= rec;
                                        if (simState[actorIdx].currentHp < 0) simState[actorIdx].currentHp = 0;
                                        this.turnQueue.push({ type: 'damage', targetIdx: actorIdx, damage: rec, effMsg: '反動を受けた！', targetName: attacker.name });
                                    }
                                }

                                // Stat Changes
                                if (effect.statChanges) {
                                    effect.statChanges.forEach(ch => {
                                        // Determine target
                                        const targetObj = (ch.target === 'self') ? attacker : defender;
                                        const targetPName = (ch.target === 'self') ? attacker.name : defender.name;

                                        // Apply (Camp -6 to 6)
                                        if (!targetObj.ranks) targetObj.ranks = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, eva: 0 };
                                        targetObj.ranks[ch.stat] += ch.stage;
                                        if (targetObj.ranks[ch.stat] > 6) targetObj.ranks[ch.stat] = 6;
                                        if (targetObj.ranks[ch.stat] < -6) targetObj.ranks[ch.stat] = -6;

                                        // Log
                                        const statNames = { atk: '攻撃', def: '防御', spa: '特攻', spd: '特防', spe: '素早さ', eva: '回避率' };
                                        const stageText = (ch.stage === 2) ? 'ぐーんと上がった'
                                            : (ch.stage === 3) ? 'ぐぐーんと上がった'
                                                : (ch.stage === 1) ? '上がった'
                                                    : (ch.stage === -2) ? 'がくっと下がった'
                                                        : '下がった';

                                        this.turnQueue.push({
                                            type: 'text',
                                            msg: `${targetPName} の ${statNames[ch.stat]} が ${stageText}！`
                                        });
                                    });
                                }
                            }

                            if (simState[targetIdx].currentHp <= 0) {
                                this.turnQueue.push({
                                    type: 'text',
                                    msg: `${defender.name} は倒れた！`
                                });
                                this.turnQueue.push({
                                    type: 'faint',
                                    targetIdx: targetIdx
                                });
                            }
                        }
                    }
                });

                this.processNextAction();
            },

            processNextAction: function () {
                if (this.turnQueue.length === 0) {
                    // End of turn processing
                    this.endTurn();
                    return;
                }

                const action = this.turnQueue.shift();
                const logBox = document.getElementById('battle-log');

                const wait = (ms) => setTimeout(() => this.processNextAction(), ms);

                if (action.type === 'text') {
                    logBox.innerText += action.msg + "\n";
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(800);
                }
                else if (action.type === 'damage') {
                    const targetP = this.players[action.targetIdx];
                    const active = targetP.team[targetP.activeIdx];
                    active.currentHp -= action.damage;
                    if (active.currentHp < 0) active.currentHp = 0;

                    // Update UI
                    this.updateHpDisplay();

                    const logMsg = action.effMsg || action.msg;
                    if (logMsg) {
                        logBox.innerText += logMsg + "\n";
                    }
                    logBox.innerText += `(HP: ${active.currentHp}/${active.stats.hp})\n`;
                    logBox.scrollTop = logBox.scrollHeight;

                    wait(1000);
                }
                else if (action.type === 'switch') {
                    const p = this.players[action.actorIdx];
                    logBox.innerText += `${p.name} は ${action.oldName} を戻して ${action.newName} を繰り出した！\n`;
                    p.activeIdx = action.newActiveIdx;
                    this.updateHpDisplay();
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(1500);
                }
                else if (action.type === 'faint') {
                    logBox.innerText += `${action.targetName || 'ポケモン'} は倒れた！\n`;
                    logBox.scrollTop = logBox.scrollHeight;
                    this.updateHpDisplay();
                    wait(1200);
                }
                else if (action.type === 'weather') {
                    this.weather = action.weather;
                    this.weatherTurns = 5; // Default 5 turns
                    const map = { sun: 'ひざしがつよい', rain: 'あめがふりだした', sandstorm: 'すなあらしがふきあれた', snow: 'ゆきがふりだした' };
                    logBox.innerText += `${map[action.weather]}！\n`;
                    logBox.scrollTop = logBox.scrollHeight;
                    wait(1000);
                }
            },

            endTurn: function () {
                const logBox = document.getElementById('battle-log');
                const p1 = this.players[0];
                const p2 = this.players[1];
                const hasAlive = (p) => p.team.some(m => m.currentHp > 0);

                // End of turn damage/effects queue
                let endQueue = [];

                if (this.endOfTurnStage === 0) {
                    this.endOfTurnStage = 1;
                    // Weather
                    if (this.weather !== 'none') {
                        this.weatherTurns--;
                        if (this.weatherTurns <= 0) {
                            endQueue.push({ type: 'text', msg: 'てんきがもとにもどった。' });
                            this.weather = 'none';
                        } else {
                            // Sandstorm damage
                            [p1, p2].forEach((p, idx) => {
                                const mon = p.team[p.activeIdx];
                                if (this.weather === 'sandstorm' && mon.currentHp > 0) {
                                    if (!mon.types.includes('rock') && !mon.types.includes('ground') && !mon.types.includes('steel')) {
                                        const dmg = Math.floor(mon.stats.hp / 16) || 1;
                                        endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'すなあらしのダメージをうけている！' });
                                    }
                                }
                            });
                        }
                    }

                    // Status Damage
                    [p1, p2].forEach((p, idx) => {
                        const mon = p.team[p.activeIdx];
                        if (mon.currentHp > 0 && mon.status) {
                            if (mon.status.condition === 'brn') {
                                const dmg = Math.floor(mon.stats.hp / 16) || 1;
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'やけどのダメージをうけている！' });
                            } else if (mon.status.condition === 'psn') {
                                const dmg = Math.floor(mon.stats.hp / 8) || 1;
                                endQueue.push({ type: 'damage', targetIdx: idx, damage: dmg, msg: 'どくのダメージをうけている！' });
                            }
                        }
                    });

                    if (endQueue.length > 0) {
                        // Temporary merge to turnQueue to process them
                        this.turnQueue = endQueue;
                        this.processNextAction();
                        return;
                    }
                }

                this.endOfTurnStage = 2; // Completed
                // Check if anyone dead needs replacement
                const p1Dead = p1.team[p1.activeIdx].currentHp === 0;
                const p2Dead = p2.team[p2.activeIdx].currentHp === 0;

                if (p1Dead) {
                    if (!hasAlive(p1)) {
                        alert("Player 2 Wins!");
                        location.reload(); // Simple reset
                        return;
                    }
                    this.currentPlayerIndex = 0; this.showSwitchScreen(true); return;
                }
                if (p2Dead) {
                    if (!hasAlive(p2)) {
                        alert("Player 1 Wins!");
                        location.reload();
                        return;
                    }
                    this.currentPlayerIndex = 1; this.showSwitchScreen(true); return;
                }

                // Show Next Turn Button or Auto
                const btn = document.querySelector('#screen-result button');
                if (btn) {
                    btn.disabled = false;
                    btn.onclick = () => {
                        this.resetTurnActions();
                        app.nextTurn();
                    };
                }
            },

            calcDamage: function (attacker, defender, move, effect = null) {
                const lv = attacker.lv;
                const power = move.power;
                if (power <= 0) return { damage: 0, superEffective: 1 };

                const atkRank = attacker.ranks ? attacker.ranks.atk : 0;
                const defRank = defender.ranks ? defender.ranks.def : 0;
                const spaRank = attacker.ranks ? attacker.ranks.spa : 0;
                const spdRank = defender.ranks ? defender.ranks.spd : 0;

                let a = (move.category === 'physical')
                    ? Math.floor(attacker.stats.atk * this.getRankMultiplier(atkRank))
                    : Math.floor(attacker.stats.spa * this.getRankMultiplier(spaRank));

                let d = (move.category === 'physical')
                    ? Math.floor(defender.stats.def * this.getRankMultiplier(defRank))
                    : Math.floor(defender.stats.spd * this.getRankMultiplier(spdRank));

                // Burn
                if (attacker.status && attacker.status.condition === 'brn' && move.category === 'physical') {
                    a = Math.floor(a * 0.5);
                }

                // Weather boosts/drops
                let weatherMult = 1.0;
                if (this.weather === 'sun') {
                    if (move.type === 'fire') weatherMult = 1.5;
                    if (move.type === 'water') weatherMult = 0.5;
                } else if (this.weather === 'rain') {
                    if (move.type === 'water') weatherMult = 1.5;
                    if (move.type === 'fire') weatherMult = 0.5;
                }

                // Weather Def/SpD boosts
                if (this.weather === 'sandstorm' && defender.types.includes('rock') && move.category === 'special') {
                    d = Math.floor(d * 1.5);
                }
                if (this.weather === 'snow' && defender.types.includes('ice') && move.category === 'physical') {
                    d = Math.floor(d * 1.5);
                }

                let baseDmg = Math.floor(Math.floor(Math.floor(2 * lv / 5 + 2) * power * a / d) / 50) + 2;
                let multi = 1.0 * weatherMult;
                let typeEff = 1.0;
                defender.types.forEach(defT => {
                    if (defT !== 'none' && TYPE_CHART[move.type] && TYPE_CHART[move.type][defT] !== undefined) {
                        typeEff *= TYPE_CHART[move.type][defT];
                    }
                });
                multi *= typeEff;
                if (attacker.types.includes(move.type)) multi *= 1.5;

                // Crit (simplified)
                const critRate = (effect && effect.meta && effect.meta.critRate) ? 2 : 0;
                const critChance = (critRate >= 2) ? 0.5 : 0.04;
                if (Math.random() < critChance) {
                    multi *= 1.5;
                }

                const rnd = (Math.floor(Math.random() * 16) + 85) / 100;

                return { damage: Math.floor(baseDmg * multi * rnd), superEffective: typeEff };
            },

            calcStats: function (prefix) {
                const getVal = (id) => {
                    const el = document.getElementById(id);
                    return el ? (parseInt(el.value) || 0) : 0;
                };
                const lv = getVal(`${prefix}_lv`);
                const natureKeyEl = document.getElementById(`${prefix}_nature`);
                const natureKey = natureKeyEl ? natureKeyEl.value : "1.0";
                const natureData = NATURE_TABLE[natureKey] || NATURE_TABLE["1.0"];

                const calc = (stat, isHp) => {
                    const base = getVal(`${prefix}_base_${stat}`);
                    const iv = getVal(`${prefix}_iv_${stat}`);
                    const ev = getVal(`${prefix}_ev_${stat}`);
                    let core = Math.floor((2 * base + iv + Math.floor(ev / 4)) * lv / 100);
                    if (isHp) return core + lv + 10;
                    else {
                        let res = core + 5;
                        if (natureData.up === stat) res = Math.floor(res * 1.1);
                        if (natureData.down === stat) res = Math.floor(res * 0.9);
                        return res;
                    }
                };
                return {
                    hp: calc('h', true), atk: calc('a', false), def: calc('b', false),
                    spa: calc('c', false), spd: calc('d', false), spe: calc('s', false)
                };
            },

            getRankMultiplier: function (stage) {
                if (stage >= 0) return (2 + stage) / 2;
                else return 2 / (2 + Math.abs(stage));
            },

            updateHpDisplay: function () {
                [0, 1].forEach(i => {
                    const p = this.players[i];
                    if (!p) return;
                    const active = p.team[p.activeIdx];
                    const nameEl = document.getElementById(`res-p${i + 1}-name`);
                    const lvEl = document.getElementById(`res-p${i + 1}-lv`);
                    const bar = document.getElementById(`res-hp-bar-p${i + 1}`);
                    const txt = document.getElementById(`res-hp-text-p${i + 1}`);

                    if (nameEl) {
                        const statusMap = { brn: ' [火傷]', par: ' [麻痺]', psn: ' [毒]', slp: ' [眠り]', frz: ' [氷]' };
                        const statusText = active.status ? statusMap[active.status.condition] : "";
                        nameEl.innerText = active.name + statusText;
                        nameEl.style.opacity = active.currentHp === 0 ? '0.4' : '1';
                    }
                    if (lvEl) lvEl.innerText = active.lv;

                    const pct = (active.currentHp / active.stats.hp) * 100;
                    if (bar) {
                        bar.style.width = pct + '%';
                        this.setHpColor(bar, pct);
                    }
                    if (txt) {
                        txt.innerText = `${active.currentHp}/${active.stats.hp}`;
                        txt.style.opacity = active.currentHp === 0 ? '0.4' : '1';
                    }
                });

                // Weather Display (Update a generic element or log)
                const logBox = document.getElementById('battle-log');
                if (logBox && this.weather !== 'none') {
                    // We could add a persistent weather indicator in future turns
                }
            },

            setHpColor: function (el, pct) {
                if (!el) return;
                el.classList.remove('hp-low', 'hp-crit');
                if (pct < 20) el.classList.add('hp-crit');
                else if (pct < 50) el.classList.add('hp-low');
            },

            performForcedSwitch: function (newIdx) {
                const p = this.players[this.currentPlayerIndex];
                const oldName = p.team[p.activeIdx].name;
                p.activeIdx = newIdx;
                const newName = p.team[p.activeIdx].name;

                // Check if we need to resume a "Death Check" loop or start next turn
                // Logic: If this was a forced switch at end of turn...
                // We should check if the OTHER player also needs to switch
                // Or if we are done, proceed to nextTurn (which starts turn cycle for P1)

                const p1Dead = this.players[0].team[this.players[0].activeIdx].currentHp === 0;
                const p2Dead = this.players[1].team[this.players[1].activeIdx].currentHp === 0;

                if (p1Dead) {
                    this.currentPlayerIndex = 0;
                    this.showSwitchScreen(true);
                    return;
                }
                if (p2Dead) {
                    this.currentPlayerIndex = 1;
                    this.showSwitchScreen(true);
                    return;
                }

                // If everyone alive, start fresh turn
                this.nextTurn();
            },

            showSwitchScreen: function (isForced) {
                this.showScreen('screen-switch');
                const p = this.players[this.currentPlayerIndex];
                const switchMsgEl = document.getElementById('switch-msg');
                if (switchMsgEl) switchMsgEl.innerText = isForced ? "強制交代: 戦闘不能です。次を選んでください" : "交代するポケモンを選択";

                const btnCancel = document.getElementById('btn-cancel-switch');
                if (btnCancel) btnCancel.style.display = isForced ? 'none' : 'block';

                const container = document.getElementById('switch-container');
                if (!container) return;
                container.innerHTML = '';

                p.team.forEach((mon, idx) => {
                    if (idx === p.activeIdx) return;
                    const card = document.createElement('div');
                    card.className = 'switch-card';

                    if (mon.currentHp === 0) card.classList.add('disabled');

                    const nameSpan = document.createElement('span');
                    nameSpan.innerText = `${idx + 1}: ${mon.name} (${mon.currentHp}/${mon.stats.hp})`;
                    card.appendChild(nameSpan);

                    card.onclick = () => {
                        if (mon.currentHp === 0) return;

                        if (isForced) {
                            this.performForcedSwitch(idx);
                        } else {
                            this.registerMove(-1, idx);
                        }
                    };
                    container.appendChild(card);
                });
            },

            cancelSwitch: function () {
                this.showScreen('screen-input');
            },

            showScreen: function (id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const el = document.getElementById(id);
                if (el) el.classList.add('active');
            },

            nextTurn: function () {
                this.showScreen('screen-curtain');
                const pNameEl = document.getElementById('curtain-msg');
                if (pNameEl) pNameEl.innerText = "ターン終了 - 次へ";
                this.startTurnCycle();
            }
        };

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            try {
                app.init();
            } catch (e) {
                console.error('app.init error:', e);
            }
        });
    </script>
</body>

</html>
